<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css3基础知识</title>
    <url>/2018/06/09/css3/</url>
    <content><![CDATA[<p>复习一下css3一些常用的姿势</p>
<span id="more"></span>

<h5 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h5><ul>
<li>css3是css2的升级版本，主流浏览器已经支持大部分的功能了，ie10后也开始全面支持css3了</li>
<li>css3前缀：在编写css3样式的时候，不同的浏览器可能需要不同的前缀，这是为了兼容各个版本的浏览器Chrome和Safari前缀为-webkit，Firefox为-moz，IE为-ms，Opera为-o</li>
</ul>
<h5 id="css3初级知识"><a href="#css3初级知识" class="headerlink" title="css3初级知识"></a>css3初级知识</h5><ul>
<li>border-radius:圆角</li>
<li>border-shadow:x轴偏移量 y轴偏移量 阴影模糊半径 阴影拓展半径 阴影颜色 投影方式 —盒子阴影，可以加多个阴影，通过逗号隔开</li>
<li>text-shadow:x-offset y-offset blur(模糊程度) color</li>
<li>背景颜色渐变gradient<ol>
<li>线性渐变 linear-gradient([direction],color[percent],color[percent],…)</li>
<li>径向渐变 radial-gradient(shape r at position,color[percent],color[percent],…)<br> 其中shape可以为circle也可以为ellipse，position为圆心位置，r为半径，椭圆的时候该位置为x和y，为长轴和短轴</li>
</ol>
</li>
<li>word-wrap:normal|bread-word;—文字边界换行</li>
<li>font-face:例子如下，其中引用多个不同格式的字体是为了兼容 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&#x27;myFont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">&#x27;sansation_Lifht.ttf&#x27;</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">&#x27;sansation_Lifht.eot&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;eot&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&#x27;myFont&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 有一个比较全的兼容版本如下 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&#x27;diyfont&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">&#x27;diyfont.eot&#x27;</span>)<span class="comment">/*ie9+*/</span></span><br><span class="line">    src:<span class="built_in">url</span>(<span class="string">&#x27;diyfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),<span class="comment">/*ie6-ie8*/</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;diyfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),<span class="comment">/*chrome,firefox*/</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;diyfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),<span class="comment">/*chrome,firefox,opera,safari,android,ios4.2+*/</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;diyfont.svg#fontname&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);<span class="comment">/*ios4.1-*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>border-image:边框应用背景 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-image</span>:<span class="built_in">url</span>(<span class="string">xxx.png</span>) number stretch|repeat|round</span><br></pre></td></tr></table></figure>
 如上，number为截取指定图片四周的宽度为border的背景填充部分，最后一个参数为展示方式，stretch为拉伸，repeat为平铺（从中间开始），round为铺满（中间的平铺，如果大于某个极限值的时候，就会进行复制，有点像响应式布局中的随宽度进行改变，像裂变一样），在计算的时候会把引用的图片切成九宫格，最后一个就为十字部分的展开方式，number为四个角的部分的宽和高</li>
<li>background-origin:border-box|padding-box|content-box; 背景图片的起始位置，默认从padding区域开始</li>
<li>background-clip:border-box|padding-box|content-box|no-clip<br> 其中webkit可以做文字的clip需要配合text-fill-color属性 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    text-fill-<span class="attribute">color</span>:-webkit-background-clip;</span><br><span class="line">    -webkit-<span class="attribute">background-clip</span>:text;</span><br><span class="line">    -webkit-text-fill-<span class="attribute">color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>background-size:auto|长度值|百分比|cover|contain<br> 其中cover为<em>铺满</em>背景，超过部分截断，contain为尽量纯在一<em>整</em>张图片  — 设置背景图片大小</li>
</ul>
<h5 id="css3选择器"><a href="#css3选择器" class="headerlink" title="css3选择器"></a>css3选择器</h5><ul>
<li>属性选择器<ol>
<li>E[att^&#x3D;’val’] 选择匹配的元素E，E定义了属性att，以val开头</li>
<li>E[att$&#x3D;’val’] 选择匹配的元素E，E定义了属性att，以val结尾</li>
<li>E[att*&#x3D;’val’] 选择匹配的元素E，E定义了属性att，属性的任意位置出现了val</li>
</ol>
</li>
<li>伪类选择器<ol>
<li>root 根标签选择器</li>
<li>not 否定选择器</li>
<li>empty 空标签选择器</li>
<li>target 目标元素选择器，用来匹配location.hash选中的元素</li>
<li>first-child|last-child|nth-child()|nth-last-child() 子元素选择器，如果当前位置元素不是前面所修饰的元素，无效（必须位置与元素相同）</li>
<li>first-of-type|last-of-type|nth-of-type()|nth-last-of-type() 该种选择器与第5种的不同就是实在元素类型中位置为选中的元素</li>
<li>only-child|only-of-type 这两个的区别于56的区别相同，是查找唯一子元素选择器</li>
<li>enabled|disabled 可用|不可用的元素，如复选框等，可以通过伪类进行选择</li>
<li>checked 选择框被选中的状态</li>
<li>read-only|read-write 选中只读|非只读的元素，配合标签上的readonly使用<br> 这些伪类选择器在使用的时候需要在前面加’:’</li>
</ol>
</li>
<li>伪元素选择器<br> 添加了first-letter first-line before after selection(匹配突出显示的文本)，selection中有个属性user-select:none;就是无法被选中的</li>
<li>伪元素和伪类的区别<br> 伪元素效果是需要通过添加一个实际的元素才能达到的<br> 伪类则是选择一类，多个元素</li>
<li>条件选择<ol>
<li>&amp;#62; 直接子元素</li>
<li>&amp;#43; 后面紧挨着的兄弟节点</li>
<li>~ 后面的兄弟节点</li>
</ol>
</li>
</ul>
<h5 id="css3进阶"><a href="#css3进阶" class="headerlink" title="css3进阶"></a>css3进阶</h5><h6 id="transform形状变换"><a href="#transform形状变换" class="headerlink" title="transform形状变换"></a>transform形状变换</h6><ul>
<li>rotate() 旋转默认为z轴方向，有rotateX|Y|3d</li>
<li>scale() 缩放，可以接收两个参数，为x轴和y轴方向上的缩放倍数，如果没有第二个参数，默认使用第一个参数，还可以分解成scaleX()&#x2F;Y&#x2F;Z，还有一个scale3d() 其中就可以填写xyz的缩放倍数</li>
<li>skew() 扭曲，同scale一样，为两个参数，但是只能分解成skewX()&#x2F;Y，在只有一个参数的时候y轴默认为0</li>
<li>translate() 移动，相对于自身进行移动，默认有两个参数可以分解为translateX|Y|Z，还有translate3d()</li>
<li>特殊的是transform-origin 作用是变换圆点，默认为中央的位置，可以通过百分比，或者关键字进行修改</li>
</ul>
<h6 id="transition过渡动画"><a href="#transition过渡动画" class="headerlink" title="transition过渡动画"></a>transition过渡动画</h6><ul>
<li>它是一个复合属性，有以下几个子属性</li>
</ul>
<ol>
<li>transition-property 过渡的css属性</li>
<li>transition-duration 过渡所需时间</li>
<li>transition-timing-function 过渡函数</li>
<li>transition-delay 延迟时间</li>
</ol>
<h6 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h6><ul>
<li>它也是一个复合属性，主要有以下的子元素</li>
</ul>
<ol>
<li>animation-name 执行动画的keyframe名，其中keyframe如下定义，如果只有0%和100%两个关键帧，可以用from to 代替 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> move&#123;</span><br><span class="line"> <span class="number">0%</span>&#123;...&#125;</span><br><span class="line"> <span class="number">10%</span>&#123;...&#125;</span><br><span class="line"> <span class="number">100%</span>&#123;...&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>animation-duration 动画执行时间</li>
<li>animation-timing-function 过渡函数速率</li>
<li>animation-delay 延迟时间</li>
<li>animation-iteration-count 定义播放次数</li>
<li>animation-direction 定义播放方向 有normal（默认值）reverse（反向播放）alternate（奇数次正向，偶数次反向）alternate-reverse（奇数次反向，偶数次正向）</li>
<li>animation-play-state 播放状态 running（播放）paused（暂停） </li>
<li>animation-fill-mode 表示在结束时发生的操作 none（默认值）forwards（停留在最后关键帧的位置）backwards（开始的时候应用初始帧的位置）both（同时具有forwards和backwars效果）</li>
</ol>
<h6 id="columns多列布局"><a href="#columns多列布局" class="headerlink" title="columns多列布局"></a>columns多列布局</h6><ul>
<li>主要应用在文本的多列布局，类似报纸杂志的那种布局方式</li>
<li>columns:[column-width] [column-count]，也是复合属性，可以分解，column-width为每一类的宽度，根据容器宽度自适应（最小宽度）；column-count为规定列数，不要两个一起使用</li>
<li>column-gap 设置列与列之间的宽度，没有的时候会按浏览器的font-size来定</li>
<li>column-rule 与border类似，是缝的样式，有width,style,color</li>
<li>column-span 设置多列布局元素内的子元素，标题只有1|all两个可选的值，1为在第一列，all为在所有列的上面中间</li>
</ul>
<h6 id="弹性盒子flex布局"><a href="#弹性盒子flex布局" class="headerlink" title="弹性盒子flex布局"></a>弹性盒子flex布局</h6><blockquote>
<p>可以观看阮一峰大佬博客中关于弹性盒子的描述，非常详细，而且有图—<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?%5E%25$">阮一峰flex布局</a></p>
</blockquote>
<ul>
<li>设置方式 display:flex</li>
<li>在子元素上设置的属性<ol>
<li>flex-grow 根据设置的比例分配盒子剩余的空间</li>
<li>flex-shrink 根据设置的比例承担超出盒子部分的大小</li>
<li>flex-basis 伸缩基准值，和width一样，但是如果设置该属性，会覆盖width属性的值</li>
<li>flex 前三个的复合体</li>
<li>order 排序，从小到大排序</li>
<li>align-self 对齐方式，允许单个子元素和其他的不同，可覆盖align-items属性，有以下的值可以填 auto|flex-start|flex-end|center|baseline|stretch auto表示继承父元素的align-items属性,如果没有父元素，等同于stretch</li>
</ol>
</li>
<li>在父元素上设置的属性<ol>
<li>flex-direction 设置主轴方向 row|row-reverse|column|column-reverse</li>
<li>flex-wrap 设置换行 nowrap|wrap|wrap-reverse</li>
<li>flex-flow 是前两个的复合体</li>
<li>justify-content 元素在主轴上的对齐方式 flex-start（默认值，左对齐）flex-end（右对齐）center（居中）space-between（两端对齐，项目之间的间隔相等）space-around（项目之间两侧的间隔相等）</li>
<li>align-items 设置在侧轴上的对齐方式 flex-start|flex-end|center|baseline|stretch</li>
<li>align-content 设置多根轴线的对齐方式 flex-start|flex-end|center|space-between|space-around|stretch</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重</title>
    <url>/2018/05/31/exercise-1/</url>
    <content><![CDATA[<p>数组去重练习</p>
<span id="more"></span>
<p>在原型链上进行编程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">var</span> len = <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj[<span class="variable language_">this</span>[i]])&#123;</span><br><span class="line">            obj[<span class="variable language_">this</span>[i]]=<span class="literal">true</span>;</span><br><span class="line">            arr.<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>exercise</tag>
      </tags>
  </entry>
  <entry>
    <title>简单判断类型</title>
    <url>/2018/05/31/exercise/</url>
    <content><![CDATA[<p>简单判断传入值的类型</p>
<span id="more"></span>
<p>可以简单判断出来numbe string boolean function undefined object array null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">target</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> strTemple = <span class="title function_">typeof</span>(target);</span><br><span class="line">    <span class="keyword">var</span> toStr =  <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line">    <span class="keyword">if</span>(strTemple == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(toStr.<span class="title function_">call</span>(target))&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object Array]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;array&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object Object]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object Number]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;object-number&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object String]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;object-string&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object Boolean]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;object-boolean&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[object Null]&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target===<span class="literal">null</span>)&#123;  <span class="comment">//兼容老版本，新版本可以通过之前的switch中case返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strTemple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>exercise</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本化css基础及事件</title>
    <url>/2018/06/01/domcss/</url>
    <content><![CDATA[<p>主要关于dom操作css的基础知识</p>
<span id="more"></span>
<ul>
<li><p>读写元素css属性</p>
</li>
<li><p>dom.style.prop<br> 可读写行间样式，没有兼容性问题，碰到关键字，需要加css，复合属性必须拆解，组合单词变成小驼峰式写法，（常用的class名需要变成className查询）</p>
</li>
<li><p>查询计算样式</p>
<ul>
<li>window.getComputedStyle(ele,null)<br>  计算样式只读，返回的计算样式的值都是绝对值，没有相对单位，并且ie8和ie8以下不兼容</li>
<li>ele.currentStyle<br>  ie独有的属性，计算样式只读，返回的计算样式的值不是经过转换的绝对值，</li>
<li>封装兼容性方法  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">ele,prop</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">getComputedStyle</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(ele,<span class="literal">false</span>)[prop]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ele.<span class="property">currentStule</span>[prop]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//其中getComputedStyle的第二个参数可以查询伪元素的样式</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查找，操作样式表（这个没怎么用过）</p>
<ul>
<li>document.styleSheets 该属性中存储了一个HTML文档里面的所有css样式表的集合</li>
</ul>
</li>
<li><p>事件<br>  事件是交互体验的核心，通过事件，我们可以与页面进行交互，是页面的灵魂，当然内容也很重要</p>
<ul>
<li>绑定事件<ol>
<li>ele.onxxx &#x3D; function (event){}<br> 兼容性很好，但是只能绑定一个处理程序，程序中this指向的是dom元素本身</li>
<li>ele.addEventListener(type,fn,false);<br> ie9以下不兼容，可以为一个事件绑定多个处理程序，程序中this指向的是dom元素本身</li>
<li>ele.attachEvent(‘on’+type,fn)<br> ie独有，也可以绑定多个处理程序，程序this指向window<br>  封装兼容性方法：在下面的方法中，改变了attachEvent中的this指向，而且存储了不同的处理程序，方便以后的事件解除  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEvent</span>(<span class="params">dom,type,handle</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dom.<span class="property">addEventListener</span>)&#123;</span><br><span class="line">        dom.<span class="title function_">addEventListener</span>(type,handle,<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dom.<span class="property">attachEvent</span>)&#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">temp</span>(<span class="params"></span>)&#123;</span><br><span class="line">            handle.<span class="title function_">call</span>(dom);<span class="comment">//硬绑定this指向dom</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="property">name</span> = handle;</span><br><span class="line">        dom[type] = dom[type]?dom[type].<span class="title function_">push</span>(temp):[].<span class="title function_">push</span>(temp);</span><br><span class="line">        dom.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span>+type,temp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dom[<span class="string">&#x27;on&#x27;</span>+type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>解除事件处理程序<ol>
<li>ele.onxxx &#x3D; false&#x2F;‘’&#x2F;null</li>
<li>ele.removeEventListener(type,fn,false)</li>
<li>ele.detachEvent(‘on’+typs,fn)<br>  如果绑定匿名函数的话，无法解除；封装解除事件函数  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeEvent</span>(<span class="params">dom,type,handle</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dom.<span class="property">removeEnentListener</span>)&#123;</span><br><span class="line">        dom.<span class="title function_">removeEventListener</span>(type,handle,<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dom.<span class="property">detachEvent</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;dom[type].<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dom[type][i].<span class="property">name</span> === handle)&#123;</span><br><span class="line">                dom.<span class="title function_">detachEvent</span>(type,dom[type][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dom[<span class="string">&#x27;on&#x27;</span>+type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>事件处理模型—事件冒泡、捕获<ul>
<li>事件冒泡 ：<br>  最开始是由ie发起的，结构上嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素</li>
<li>事件捕获：<br>  由火狐支持的，结构上嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）</li>
<li>触发顺序 先捕获，后冒泡 ie没有捕获，火狐没有冒泡，Chrome都有，另外focus、blur、change、submit、reset、select等事件不冒泡</li>
<li>取消冒泡和阻止默认事件<ul>
<li>取消冒泡<ol>
<li>W3C标准 event.stopPropagation() ie9一下不支持</li>
<li>ie独有的event.cancelBubble &#x3D; true<br>  封装取消冒泡函数  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stopBubble</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">stopPropagation</span>)&#123;</span><br><span class="line">        event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>阻止默认事件<ol>
<li>return false;以对象属性的方式注册的事件才生效</li>
<li>event.preventDefault();W3C标准，ie9以下不兼容</li>
<li>event.returnValue &#x3D; false;兼容ie<br>  默认事件包括表单提交，a标签点击跳转，右键菜单等，封装阻止默认事件的函数  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cancelHandler</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">preventDefault</span>)&#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.<span class="property">returnValue</span>)&#123;</span><br><span class="line">        event.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li>事件对象<br>  event||window.event 后面的用于ie<br>  事件源对象：1.event.target 火狐独有 2.event.srcElement ie独有的 ；而这两个Chrome都有，兼容性写法  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">e = event||<span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">eventTarget = e.<span class="property">target</span>||e.<span class="property">srcElement</span>;</span><br></pre></td></tr></table></figure></li>
<li>事件委托<br>  利用事件冒泡，对事件源对象进行处理，比如在ul中包含大量的li，li的点击事件就可以在ul中绑定，然后利用事件冒泡，在ul的点击事件中处理，优点如下：1.性能 不需要循环所有的元素一个个绑定事件 2.灵活 当所有新的子元素时不需要重新绑定事件</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>dom</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2018/05/31/js-1/</url>
    <content><![CDATA[<p>在学习闭包前，我们需要一些知识，这些知识会方便我们学习闭包</p>
<span id="more"></span>

<ul>
<li>js运行三部曲</li>
</ul>
<ol>
<li>语法分析（自己写错了代码等）</li>
<li>预编译（重点）</li>
<li>解释执行</li>
</ol>
<h5 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h5><ul>
<li>预编译前奏<ol>
<li>暗示全局变量：如果变量未经声明就赋值，此变量为全局对象所有（严格模式报错），需要注意的是 var a &#x3D; b &#x3D; 123;这种样子的，其中变量b并没有被声明，所以b也是全局对象所有的</li>
<li>一切声明的全局变量都是window的属性，window上的属性在使用时，不需要写window；</li>
</ol>
</li>
<li>预编译四部曲<ol>
<li>创建AO对象（执行期上下文）</li>
<li>找函数里面的形参和变量声明，并变成AO的属性名，值为undefined</li>
<li>实参与形参统一</li>
<li>找到函数声明，变成AO的属性名，并把函数体当做值赋给它</li>
</ol>
</li>
<li>执行的时候就变量声明和函数定义等，已经完成了提升，这是声明语句就会被忽略掉，进而去执行语句，这时就是解释执行阶段</li>
</ul>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><ul>
<li>运行期上下文：当函数执行时，会创建一个称谓执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时的执行上下文都是独一无二的，所以多次电泳一个函数会导致创建多个执行上下文，函数每次执行时都会把新生成的执行期上下文，填充到作用域链的最顶端，当函数执行完毕，它产生的执行上下文被销毁 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">234</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glob = <span class="number">100</span>;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数创建的时候，继承当前所在的作用链，执行的时候，把预编译产生的activation object对象放到执行期上下文的顶部</span></span><br><span class="line"><span class="comment">1. 当a创建时 </span></span><br><span class="line"><span class="comment">a.[[scope]] --&gt; scope chain</span></span><br><span class="line"><span class="comment">                 0         --&gt; global object       &#123;this:window,window:&#123;&#125;,document:&#123;&#125;,a:fn,glob:100&#125;</span></span><br><span class="line"><span class="comment">2. 当a函数执行的时候</span></span><br><span class="line"><span class="comment">a.[[scope]] --&gt;scope chain</span></span><br><span class="line"><span class="comment">                 0         --&gt; activation object   &#123;this: window,arguments:[],a:123,b:fn&#125;</span></span><br><span class="line"><span class="comment">                 1         --&gt; global object       &#123;this:window,window:&#123;&#125;,document:&#123;&#125;,a:fn,glob:100&#125;                      </span></span><br><span class="line"><span class="comment">3. 当b创建时，b会继承a的作用域链</span></span><br><span class="line"><span class="comment">b.[[scope]] --&gt;scope chain</span></span><br><span class="line"><span class="comment">                 0         --&gt; activation object   &#123;this: window,arguments:[],a:123,b:fn&#125;</span></span><br><span class="line"><span class="comment">                 1         --&gt; global object       &#123;this:window,window:&#123;&#125;,document:&#123;&#125;,a:fn,glob:100&#125;         </span></span><br><span class="line"><span class="comment">4. 当b函数执行的时候</span></span><br><span class="line"><span class="comment">b.[[scope]] --&gt;scope chain</span></span><br><span class="line"><span class="comment">                 0         --&gt; activation object   &#123;this:window,argument:[],b:234&#125;  </span></span><br><span class="line"><span class="comment">                 1         --&gt; activation object   &#123;this: window,arguments:[],a:123,b:fn&#125;               </span></span><br><span class="line"><span class="comment">                 2         --&gt; global object       &#123;this:window,window:&#123;&#125;,document:&#123;&#125;,a:fn,glob:100&#125;    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>闭包<br>  闭包就是源于上面作用域产生的，例如上面例子中的b函数不执行，而是直接返回，这样的话，首先a函数执行结束，掐断自己的作用域链指向，而在返回的b中，仍然还保存a的activation object ，此时就产生了闭包，闭包造成了内存泄露，但是却产生了一些非常好的特性，1.实现共有变量2.可以做缓存3.可以实现封装，属性私有化4.模块化开发，防止污染全局变量</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>html相关</title>
    <url>/2020/05/10/html/</url>
    <content><![CDATA[<p>html相关知识合集</p>
<span id="more"></span>

<h5 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h5><ul>
<li>Doctype 告诉浏览器使用了哪个版本的HTML &#x2F; XHTML标准以及如何呈现页面。浏览器有两种html渲染模式，分别是标准模式和混杂模式，如果使用DOCTYPE则使用标准模式，采用最新的标准，否者使用混杂模式向前兼容（主要不同如盒模型）<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="行元素、块元素和行级块元素"><a href="#行元素、块元素和行级块元素" class="headerlink" title="行元素、块元素和行级块元素"></a>行元素、块元素和行级块元素</h5><ul>
<li>行元素<ol>
<li>不能设置宽和高，根据自身内容决定占据空间大小</li>
<li>包括：span a em stong del</li>
</ol>
</li>
<li>块元素<ol>
<li>可以设置宽和高，独自占据一整行</li>
<li>包括：div p ol li ul form address</li>
</ol>
</li>
<li>行级块元素<ol>
<li>可以设置宽和高，根据自身内容决定占据空间大小</li>
<li>包括：input img</li>
</ol>
</li>
</ul>
<h5 id="src与href区别"><a href="#src与href区别" class="headerlink" title="src与href区别"></a>src与href区别</h5><ul>
<li>src <ol>
<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置。</li>
</ol>
</li>
<li>href<ol>
<li>href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链属接。</li>
</ol>
</li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li>p标签的子元素不能是div</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/2018/05/31/js-2/</url>
    <content><![CDATA[<p>今天来学习学习原型的知识</p>
<span id="more"></span>

<ul>
<li>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">lastName</span> = <span class="string">&#x27;father&#x27;</span>;<span class="comment">// prototype原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;person&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//person = &#123;name:&#x27;person&#x27;&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//person = &#123;name:&#x27;person&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">lastName</span>)<span class="comment">// &#x27;father&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">lastName</span>)<span class="comment">// &#x27;father&#x27;   person 和 person1 公用lastName</span></span><br></pre></td></tr></table></figure></li>
<li>构造函数的内部实现  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// var this = &#123;</span></span><br><span class="line">        <span class="attr">__proto__</span>:<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="comment">// return this;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>constructor<br>  查询构造器的属性Person.prototype.constructor为Person 所以在调用person.consturctor的时候会返回Person，可以new一下这个属性执行，构造出于person相似的对象</li>
</ul>
</li>
<li>原型链<br>  当函数使用属性或者方法的时候，会首先从自己的属性和方法中寻找，如果有的话，就执行，如果没有的话，会沿着__proto__属性进行查找，并一直重复这项操作，直到找到，或者查到最顶级（就是Object构造函数的原型，即Object.prototype，它的__proto__为null），返回undefined</li>
<li>call&#x2F;apply<br>  作用：改变this指向<br>  区别：传参方式不同  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,age,sex);</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,[name,age,sex]);</span><br></pre></td></tr></table></figure></li>
<li>继承发展史<ul>
<li>传统形式 —&gt;原型链 效率低</li>
<li>借用构造函数  每次调用多执行一次构造函数</li>
<li>共享原型      如果改变原型的话会改变共享这个原型的所有构造函数    </li>
<li>圣杯模式      比较完美的解决了共享原型的缺点  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圣杯模式</span></span><br><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="keyword">var</span> inherit = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">Origin, Target</span>)&#123;</span><br><span class="line">        F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">        <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">        <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Target</span>;</span><br><span class="line">        <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">uber</span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">Origin, Target</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Target</span>;</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property">prototye</span>.<span class="property">uber</span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>命名空间<br>  管理变量，防止污染全局，适用于模块化开发（感觉现在也不怎么用了，有webpack等打包工具，还有ES6新语法，闭包等方法）</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆</title>
    <url>/2018/05/31/js-3/</url>
    <content><![CDATA[<p>对象的克隆学习</p>
<span id="more"></span>
<ul>
<li><p>浅层克隆</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin, target</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(origin.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            target[prop] = origin[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>存在的问题：当克隆的元素为引用值的时候，由于origin和target中的元素指向同一个地址，所以当其中一个改变了元素中的值的时候，另一个也发生了改变，于是我们来学习深度克隆</li>
</ul>
</li>
<li><p>深层克隆<br>  首先判断引用值可以用typeof()，然后为了区别对象和数组，可以使用以下的方法：</p>
<ol>
<li>Object.prototype.toString</li>
<li>constructor</li>
<li>instanceof  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin,target</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> toStr = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>,</span><br><span class="line">        compare = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">if</span>(origin.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">typeof</span>(origin[prop])==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                target[prop]=(toStr.<span class="title function_">call</span>(origin[prop])==compare)?[]:&#123;&#125;;</span><br><span class="line">                <span class="title function_">clone</span>(origin[prop],target[prop])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[prop] = origin[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  通过以上的代码，就可以解决浅层克隆的问题</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>exercise</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础（一）</title>
    <url>/2018/04/17/js1/</url>
    <content><![CDATA[<h2 id="Js历史"><a href="#Js历史" class="headerlink" title="Js历史"></a>Js历史</h2><p>JavaScript在浏览器中的首次出现是在1996年，为了改善网页的用户体验，作者是Brendan Eich （关于这个语言的命名就比较有意思了，当时为了宣传采用的这个名字，没错，就是想蹭Java的热度）；接下来就是这个语言的运行环境了，所以接下来，我们来了解一下浏览器 </p>
<span id="more"></span>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器由shell和内核组成，内核中的js引擎就是与该语言最相关的东西了</p>
<p>2001年IE6发布，实现了对js引擎的优化，2008年Google发布了Chrome浏览器，这时采用的就是大名鼎鼎的V8引擎（当然不是汽车上的啦），此后Firefox也推出了强大的js引擎，再然后js就开始大力发展了。。。。。。</p>
<p>以下就是浏览器中最主要的五大主流浏览器及内核：</p>
<h3 id="五大主流浏览器及其内核"><a href="#五大主流浏览器及其内核" class="headerlink" title="五大主流浏览器及其内核"></a>五大主流浏览器及其内核</h3><h4 id="浏览器-内核"><a href="#浏览器-内核" class="headerlink" title="浏览器    内核"></a>浏览器    内核</h4><ul>
<li>Chrome    Blink&#x2F;Webkit</li>
<li>IE        trident</li>
<li>firefox   Gecko</li>
<li>opera     presto&#x2F;Blink</li>
<li>safari    Webkit</li>
</ul>
<p>是不是很惊讶没有国产浏览器，这里要说明一下主流浏览器，这些主流浏览器不仅仅用户量大，而且拥有自己的内核，这与国产浏览器是有区别的，国产浏览器使用的都是以上主流浏览器的内核，最重要的是内核没有自己的突破，依赖于以上这些强大的内核</p>
<h2 id="Js的语言特性"><a href="#Js的语言特性" class="headerlink" title="Js的语言特性"></a>Js的语言特性</h2><ul>
<li>解释性语言    不需要编译，跨平台性好</li>
<li>单线程</li>
</ul>
<p>在Js发展初期，语言规范混乱，为了取得技术优势，方便推广，进行了语言的统一规范，就是ECMA标准，因此我们更喜欢称Js为ECMAScript。但是在此说明，Js不仅仅只有ECMAScript，它还包括DOM，BOM部分</p>
<p>第一次写博客，请多多包涵，如有错误，还请不吝赐教，谢谢 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js事件——点击事件与失焦事件冲突解决</title>
    <url>/2018/05/09/js2/</url>
    <content><![CDATA[<blockquote>
<p>前端菜鸟，哈哈哈，在练习的过程中，遇到了事件冲突问题，并通过薅头发的方法得以解决，希望通过和大佬们进行讨论，学习一下是否有更好的解决方法</p>
</blockquote>
<span id="more"></span>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>  如豆瓣搜索框，在搜索时，会显示一个下拉列表，这个时候如果点击搜索框外面，会触发blur事件，下拉列表隐藏；如果点击下拉列表，则会跳转到相应的页面，在练习过程中，这个环节出了一些问题，我的部分代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;blur&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    $(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">css</span>(&#123;<span class="attr">display</span>:<span class="string">&#x27;none&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果在点击下拉列表的时候无法进行跳转（在下拉列表中有a标签包裹，所以利用默认事件进行跳转页面）</p>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>通过分析可以知道整体操作只与click事件和blur事件有关，故此判断触发顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;blur&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>由此可知，先触发了blur事件，然后触发了click事件，所以，在blur事件中使list的display：none；就会在触发click事件之前把a隐藏，这样的话，就无法点击a标签，进而无法触发点击事件</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>利用事件冒泡，首先无论如何blur事件一定先触发，所以隐藏list不能在blur事件中处理，那么应该在click事件中处理，又因为不能单单在a标签中处理（否则点击页面其他部分触发blur事件时就无法使list隐藏），所以利用事件冒泡，在body上进行隐藏处理，代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span>!==<span class="string">&#x27;INPUT&#x27;</span>)&#123;</span><br><span class="line">        $(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">css</span>(&#123;<span class="attr">display</span>:<span class="string">&#x27;none&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过判断事件源如果不是点击输入框，就可以判断为点击到了外部，此时会默认触发blur事件，而且会使list隐藏；如果点击的是输入框，则不隐藏list</p>
<p>掘金 P-der，希望得到大佬指教</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识（二）</title>
    <url>/2018/05/24/js4/</url>
    <content><![CDATA[<p>这篇先讲一下类型转换的问题</p>
<span id="more"></span>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li>显示类型转换<ul>
<li>Number(mix) 转化为number</li>
<li>String(mix) 转化为string</li>
<li>Boolear(all) 转化为boolear</li>
<li>parseInt(string,radix)<br>  第二个参数为指定的转换基数（2~36）；如parseInt(‘11’,2)输出为3；在没有第二个参数时，要注意以0x开头的string会使radix默认为16进制，所以希望大家默认都加上第二个参数，防止出现意想不到的bug，并且该函数只解析整数</li>
<li>parseFloat(string)<br>  该函数还可解析浮点数</li>
<li>toString(radix)<br>  只有number类型的toString方法可以接收radix，使得变成相应进制的string，如 var n &#x3D; 17;var m &#x3D; n.toString(2);此时m等于’10001’</li>
</ul>
</li>
<li>隐式类型转换<ul>
<li>isNaN()<br>  会把参数进行隐式类型转换</li>
<li>++&#x2F;– ,+&#x2F;-(一元正负)</li>
<li><ul>
<li></li>
</ul>
</li>
<li>*&#x2F;%</li>
<li>&amp;&amp; || !</li>
<li>&lt; &gt; &lt;&#x3D; &gt;&#x3D;</li>
<li>&#x3D;&#x3D; !&#x3D; (该点需注意，如果不希望有隐式类型转换的话，可以使用 &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>快排学习</title>
    <url>/2018/05/21/js3/</url>
    <content><![CDATA[<blockquote>
<p>前段时间逛掘金的时候，看到了掘金上的热门，关于快速排序的，虽然那篇文章很有争议，我还是看了看，发现了自己的一些不足，于是学习了一下快速排序</p>
</blockquote>
<span id="more"></span>

<h3 id="快速排序介绍"><a href="#快速排序介绍" class="headerlink" title="快速排序介绍"></a>快速排序介绍</h3><pre><code>算法导论上是这样写的
</code></pre>
<blockquote>
<p>对一个典型子数组A[p..r]排序的分治过程的三个步骤：</p>
</blockquote>
<h6 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h6><p>  数组A[p..r]被划分成两个（可能空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A(q)，而且，小于等于A[q+1..r]中的元素。小标q也在这个划分过程中进行计算。</p>
<h6 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h6><p>  通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]排序。</p>
<h6 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h6><p>  因为两个子数组是就地排序的，将它们的合并不需要操作：整个数组A[p..r]已排序。</p>
<pre><code>下面的过程实现快速排序：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line"> if&lt;r</span><br><span class="line">  then q &lt;-- PARTITION(A,p,r)</span><br><span class="line">   QUICKSORT(A,p,q-1)</span><br><span class="line">   QUICKSORT(A,q+1,r)   </span><br></pre></td></tr></table></figure>
为排序一个完整的数组A，最初的调用是QUICKSORT(A,1,length[A])。
</code></pre>
<h6 id="数组划分"><a href="#数组划分" class="headerlink" title="数组划分"></a>数组划分</h6><pre><code>快速排序算法的关键是PARTITION过程，它对子数组A[p..r]进行就地重排：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PARTITION(A,p,r)</span><br><span class="line"> x &lt;-- A[r]</span><br><span class="line"> i &lt;-- p-1</span><br><span class="line"> for j &lt;-- p to r-1</span><br><span class="line">  do if A[j]&lt;=x</span><br><span class="line">   then i &lt;-- i+1</span><br><span class="line">    exchange A[i]&lt;--&gt;A[j]</span><br><span class="line"> exchange A[i+1]&lt;--&gt;A[r]</span><br><span class="line"> return i+1</span><br></pre></td></tr></table></figure>
</code></pre>
<h6 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h6><p><img src="https://images2015.cnblogs.com/blog/634705/201509/634705-20150921205939850-1052509861.png" alt="快速排序图解（无耻抠图）"></p>
<h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><pre><code class="JavaScript">function quicksort(arr,l,r)&#123;
    if(l&lt;r)&#123;
        var q = partition(arr,l,r);
        quicksort(arr,l,q-1);
        quicksort(arr,q+1,r);
    &#125;
&#125;
function partition(arr,l,r)&#123;
    var x = arr[r];
    var i = l-1;
    for(var j = l;j&lt;r;j++)&#123;
        if(arr[j]&lt;=x)&#123;
            i++;
            var temp = arr[j];
            arr[j] = arr[i];
            arr[i] = temp;
        &#125;
    &#125;
    arr[r] = arr[i+1];
    arr[i+1] = x;
    return i+1;
&#125;
</code></pre>
<p>以上就是快排的基本实现，仿照算法导论进行的编写，嘿嘿嘿  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识（一）</title>
    <url>/2018/05/24/js/</url>
    <content><![CDATA[<blockquote>
<p>在web基础中已经讲过了js的历史，下面来进行进一步的学习</p>
</blockquote>
<p>js的三大部分</p>
<ul>
<li>ECMAScript</li>
<li>DOM</li>
<li>BOM</li>
</ul>
<span id="more"></span>

<h3 id="如何引入js"><a href="#如何引入js" class="headerlink" title="如何引入js"></a>如何引入js</h3><ol>
<li>页面内嵌<script></script>标签</li>
<li>外部引入<script src = '***'></script></li>
<li>另外还有在html标签中书写js代码（PS：不推荐）<br> 为符合w3c的规范，即结构、样式和行为相分离，所以我们通常采用外部引用，学会了js的引用后我们来学习js的基本语法</li>
</ol>
<h3 id="js基本语法"><a href="#js基本语法" class="headerlink" title="js基本语法"></a>js基本语法</h3><ul>
<li>变量<ul>
<li>变量声明<br>  由于js是弱类型语言，所以类型之间可以相互转化，变量的声明非常简单 var a；如此就声明了一个变量a</li>
<li>命名规则</li>
</ul>
<ol>
<li>变量名必须以英文字母、_、$开头</li>
<li>变量名可以包括英文字母、_、$、数字</li>
<li>不可以用系统的关键字、保留字作为变量名</li>
</ol>
</li>
<li>值类型（es6中新增的暂且不提）        <ul>
<li>原始值<br>  number string Boolean undefined null </li>
<li>引用值<br>  array object function </li>
<li>原始值与引用值的区别<br>  原始值属于栈数据，引用值属于堆数据；简单来栈的地址中存储的是值，而堆数据中存储的是地址，这个地址指向的地址中存储了值。<br>  正因为这一点，在引用值a赋值给引用值b时，改变a中或b中的值时，由于此时拷贝给b的是地址中的地址，所以，由于地址中地址中的值改变了，而地址中的地址没有改变，所以a与b共享了这种改变；而改变变量中的原始值其实就是把变量指向的地址改变了，赋值也是把其中真实的值进行copy，也因为上面说的，两个看着相等的引用值变量也很有可能不相等，因为在相等的比较中，比较的是指向地址中的值，而引用值指向的地址中是其他的地址，所以说如果这两个引用值之前没有赋值的关系，那么它们很有可能就不相等</li>
</ul>
</li>
<li>js语句的基本规则<ul>
<li>语句后面要用分号结束’;‘(ps:一般会自动补全，但最好按规矩来，有可能自动补全的不是你想的那样)</li>
<li>js语法错误会引发后继代码终止，但不影响其他的js代码块</li>
<li>书写格式要规范 （这点可以自己去按自己喜欢的学习一下，或者学习公司的相应规范）</li>
</ul>
</li>
<li>js运算符<ul>
<li>‘+’<ol>
<li>数学运算，字符串拼接</li>
<li>任何数据类型和字符串相加都等于字符串，也就是说会发生隐式类型转换，会把其他数据转换成string类型</li>
</ol>
</li>
<li>‘-‘、’*’、’%’、’&#x3D;’、’()’ </li>
<li>‘&#x3D;’的优先级最弱</li>
<li>‘++’、’–’、’+&#x3D;’、’&#x2F;&#x3D;’、’*&#x3D;’、’%&#x3D;<br>  这些都是由基本的运算符简写出来的，如a++ 就是a &#x3D; a + 1; a +&#x3D; b就是a &#x3D; a + b;其中++和–有些特别的地方，和c++一样存在a++ 和++a 的问题，这里简单说一下，a++是先用再加，++a是先加再用，如b &#x3D; a++;此时b &#x3D; a;b &#x3D; ++a;此时b &#x3D; a + 1    </li>
<li>比较运算符<ul>
<li>‘&gt;’、’&lt;’、’&#x3D;&#x3D;’、’&gt;&#x3D;’、’&lt;&#x3D;’、’!&#x3D;’<br>  比较结果为Boolean，也存在类型转换</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>‘&amp;&amp;’、’||’、’!’<br>   运算结果为真实的值，其中：’&amp;&amp;’是从前向后找，直到找到值为false的值就返回，如果没有返回最后一个值；’||’是从前向后找，直到找到一个为true的值就返回，否则就返回最后一个</li>
</ul>
</li>
<li>会被认为是false的值<ul>
<li>undefined null NaN ‘’ 0 false</li>
</ul>
</li>
<li>条件语句<ul>
<li>if、 if else if</li>
<li>for</li>
<li>while、 do while</li>
<li>switch case  （ps：注意要在每个case中添加break，防止进行下一个case中）</li>
<li>break 、 continue 、 return</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>好了，这篇就先介绍到这里了，拜拜</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识（三）</title>
    <url>/2018/05/24/js5/</url>
    <content><![CDATA[<p>这篇主要写关于array（没有讲ES5中的一些新方法）</p>
<span id="more"></span>

<h5 id="数组介绍"><a href="#数组介绍" class="headerlink" title="数组介绍"></a>数组介绍</h5><p>数组是值的有序集合。在js中数组的值可以是任何类型。每个值对应的位置成为索引；js数组是js对象的特殊形式，所以有一种说法是，在js中一切皆对象，js中允许的索引为32位</p>
<h5 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h5><ul>
<li>数组的创建<br> 数组创建的最简单方法是数组直接量； <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,&#123;&#125;,[<span class="number">1</span>,<span class="number">2</span>],<span class="literal">false</span>];</span><br></pre></td></tr></table></figure>
 数组的另外一种方法就比较麻烦 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//相当于 var arr = [];</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>); <span class="comment">//相当于创建了一个长度为10的空数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,&#123;&#125;,[<span class="number">1</span>,<span class="number">2</span>],<span class="literal">false</span>); <span class="comment">//这个就相当于 var arr1 = [1,&#x27;2&#x27;,&#123;&#125;,[1,2],false];</span></span><br></pre></td></tr></table></figure>
 所以我们通常使用数组直接量的方法进行创建，因为简单太多了</li>
<li>数组的基础操作<ul>
<li>查找<br>  通过[]中添加索引进行查找 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// 1</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>添加<br>  添加和改写array中的元素是一样的 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span>; <span class="comment">//arr为[1,2,3,4];</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//arr为[0,2,3,4];</span></span><br></pre></td></tr></table></figure></li>
<li>数组的长度<br>  数组的长度就数组中元素的个数 通过 ‘ .’的形式使用，并且可以通过改变数组的长度进行删除和添加数组 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">3</span>; <span class="comment">// arr 为 [0,1,2]</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">4</span>; <span class="comment">// arr 为 [0, 1, 2, empty] empty是空值的意思  </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数组方法    <ul>
<li>join()<br>  该方法可以将数组拼接成字符串，返回值为拼成的字符串，有一个参数，使用该参数进行拼接，如果没有的话，默认为以’,’进行拼接，如果数组中的元素也是数组也会被打开进行拼接，如果是对象的话，会使用Object.prototype.toString(item); 这样的话就会拼成’[object Object]’,如下 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">join</span>(); <span class="comment">// &#x27;1,2,3&#x27;</span></span><br><span class="line">arr = [[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],[<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line">arr.<span class="title function_">join</span>(); <span class="comment">// &#x27;1,2,3,4,5,6&#x27;</span></span><br><span class="line">arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&#123;<span class="attr">name</span>:<span class="string">&#x27;pde&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;];</span><br><span class="line">arr.<span class="title function_">join</span>() <span class="comment">// &#x27;1,2,3,[object Object]&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>reverse()<br>  逆转，改变了原数组，返回值为原数组</li>
<li>sort()<br>  排序，如果没有参数，则进行最简单的排序，按照数字大小和字母表进行排序，注意字符串的比较与数字不同，字符串是由第一位开始比较，如果数组中的元素不是原始值，进行隐式类型转化比较，其中为undefined的元素，会被放到数组的尾部；sort最强大点，在于它的参数，它的参数是一个函数 通过返回值进行排序；返回值为原数组 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>,<span class="number">4</span>,<span class="number">1111</span>,<span class="number">222</span>];</span><br><span class="line">a.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;       <span class="comment">// 返回值为正数，a,b互换位置，ab分别是前一个元素和后一个元素的值，负数不变</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>concat()<br>  返回值为一个新数组，新数组的元素包括调用concat的数组和其中的参数，如果其中的参数为数组，连接的是该数组中的元素，并不是数组本身，但并不会扁平化数组的数组</li>
<li>slice()<br>  返回数组的一段，第一个参数为起始位置，第二个参数为终止位置，若没有第二个的话，则一直到结尾，如果参数为负数的话，相当于再加上length的数为参数 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 返回[1,2,3]</span></span><br></pre></td></tr></table></figure></li>
<li>splice()<br>  这个方法比较6，一共可以填多个参数；第一个为删除的起始位置，第二个为删除的个数，后面的为插入其中的元素；返回值为剪切下来的元素组成的数组，会改变原数组</li>
<li>push()和pop(); unshift()和shift()<br>  push()为向数组的后面添加元素，返回数组长度；pop()为在数组后面删除一个元素，返回删除的值；unshift()为在数组前面添加元素，返回数组长度；shift()为在数组前面删除一个元素，并返回删除的值</li>
<li>toString()<br>  这里的toString()与没有参数的join()结果一样</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识（四）</title>
    <url>/2018/05/25/js6/</url>
    <content><![CDATA[<p>这篇主要是ES5中的一些array方法</p>
<span id="more"></span>

<ul>
<li>forEach()<br>  遍历数组并使每一个元素都调用指定的函数,需要注意的是无法终止遍历，只能通过try才能停止 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item,index,array</span>)&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//源码仿写</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> (<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       <span class="title function_">func</span>(arr[i],i,arr);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>map()<br>  该方法将每个元素使用指定的函数，并返回一个新数组，不改变原数组 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item,index,array</span>)&#123;</span><br><span class="line">    <span class="comment">/* .... */</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*处理完的某个值，由这些值组成新的数组*/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//源码仿写</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">var</span> newArr = [];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       newArr.<span class="title function_">push</span>( <span class="title function_">func</span>(arr[i],i,arr) );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>filter()<br>  该方法就是它的意思，过滤，把每一个元素进行判断，返回true或false，最后生成一个新的数组 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item,index,arr</span>)&#123;</span><br><span class="line">   <span class="comment">/* ... */</span> </span><br><span class="line">   <span class="keyword">return</span> ;<span class="comment">//返回true，保留，反之，删除</span></span><br><span class="line">&#125;)<span class="comment">//最后会返回一个新数组</span></span><br><span class="line"><span class="comment">//源码仿写</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> (<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">var</span> newArr = [];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="title function_">func</span>(arr[i],i,arr))&#123;</span><br><span class="line">           newArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>every()和some()<br>  这两个方法，一个是判断每一个，一个是判断存在一个就行，也就是说every针对所有，必须所有都满足才为true，而some是存在一个就行就返回true；并且，some在遇到第一个true时就结束遍历；every在遇到第一个false时结束遍历 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">item,index,arr</span>)&#123;</span><br><span class="line">   <span class="comment">/* ... */</span> </span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;)<span class="comment">//最后会返回true或false;</span></span><br><span class="line">arr.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">item,index,arr</span>)&#123;</span><br><span class="line">   <span class="comment">/* ... */</span> </span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;)<span class="comment">//最后会返回true或false;</span></span><br><span class="line"><span class="comment">//源码仿写</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">some</span> = <span class="keyword">function</span> (<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="title function_">func</span>(arr[i],i,arr))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">some</span> = <span class="keyword">function</span> (<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> arr = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="title function_">func</span>(arr[i],i,arr))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>reduce()和reduceRight()<br>  使用指定的函数将数组元素进行组合，生成单一值 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">x,y</span>)&#123;<span class="keyword">return</span> x+y&#125;,<span class="number">0</span>); <span class="comment">// 求和 </span></span><br></pre></td></tr></table></figure>
  运行过程是把第二个参数和数组中的第一个元素传入函数，分别对应xy，并把返回值作为下一个的x，y为下一个元素，如果没有第二个参数的话，会把第一个元素当做x，第二个元素为y，进行以上的运算<br>  reduce()和reduceRight()的区别是，以上的运行过程，reduceRight则完全相反，第一个y为最后一个元素</li>
<li>indexOf()和lastIndexOf()<br>  indexOf 从前向后查找数组中是否含有给定的元素，返回找到的第一个元素的索引值，没有的话返回-1；lastIndexOf与indexOf的查找顺序相反，需要注意的是字符串也有该方法，并且用法一样</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识（五）</title>
    <url>/2018/05/27/js7/</url>
    <content><![CDATA[<p>该篇主要介绍函数的相关内容</p>
<span id="more"></span>

<blockquote>
<p>在JavaScript中，函数也是一种对象，针对对象的操作方法也可以对函数使用</p>
</blockquote>
<h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123;    <span class="comment">// 函数声明 fn不可以省略</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b</span>)&#123; <span class="comment">// 函数定义表达式 其中fn可以省略</span></span><br><span class="line">    <span class="comment">/* ...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">// 立即执行函数</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h5 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h5><ul>
<li>作为函数的调用 fn()</li>
<li>作为方法 obj.fn()</li>
<li>作为构造函数</li>
<li>通过call()和apply()间接调用<br> 主要来看一下构造函数的这种调用方法<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br></pre></td></tr></table></figure>
 上面就是构造函数的定义与使用方法，通过new进行调用，这点是js语言仿照类一样，通过new创造了Fn的实例，本质上如下进行实现的 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">this</span> = &#123;&#125;; <span class="comment">//其实并不是完全的空对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 如上所示实际上是在内部进行隐式的创建了一个this变量，通过里面的代码，构建完对象后把他返回，注意构造函数中如果有返回的话，返回值为对象，那么不会返回this，而是返回对象，如果返回的不是对象的话，还是返回this<h6 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h6> 通过call和apply来进行调用，call和apply的区别是传参列表不同，call是一个一个参数传，apply是以数组的形式进行传参 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,a,b,c);</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,[a,b,c]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p> 在这里是由于js语言的函数作用域产生的，主要表现在通过return的方式使得在函数内部的变量可以在外部进行使用，但是闭包的产生会造成内存泄露，下面来看一个比较常见的问题<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        arr[i] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = <span class="title function_">test</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>;j++) &#123;</span><br><span class="line">  myArr[j]();    <span class="comment">//会打印出10个10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 以上的问题就是由于闭包产生的，因为myArr中每一个函数中的i对应的都是test中的i，这就使得在arr中的函数被调用的时候，从test中临时取i，而i经过for循环已经变成了10，所以最后打印出来的都是10,这个问题的解决如果用ES6的话，可以直接把函数中的for循环中的var变成let，这样的话就可以完美解决，但是基础的话还可以用立即执行函数来解决<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">            arr[j] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = <span class="title function_">test</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)&#123;</span><br><span class="line">    myArr[j])()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="常用的属性方法等"><a href="#常用的属性方法等" class="headerlink" title="常用的属性方法等"></a>常用的属性方法等</h5><ul>
<li>length属性（这里指的是arguments.length，arguments是函数体中的参数列表，是类数组）</li>
<li>prototype（原型，以后会细说这个属性）</li>
<li>call()和apply()</li>
<li>bind()（该方法是ES5中的方法，用于改变函数中的this指向问题）</li>
<li>toString()</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端JavaScript时间线</title>
    <url>/2018/05/28/js8/</url>
    <content><![CDATA[<blockquote>
<p>复习一下权威指南上的东西</p>
</blockquote>
<span id="more"></span>
<h4 id="JavaScript程序执行的时间线"><a href="#JavaScript程序执行的时间线" class="headerlink" title="JavaScript程序执行的时间线"></a>JavaScript程序执行的时间线</h4><ol>
<li>web浏览器创建document对象，并且开始解析web页面，解析html元素和它们的文本内容后添加element对象和text节点到文档中。在这个阶段document.readyState属性的值时’loading’</li>
<li>当html解析器遇到没有async和defer属性的script元素时，它把这些元素添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载（如果需要）和执行时解析器会暂停。这样脚本就可以用document.write()来把文本插入到输入流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为，在它们执行时已经存在了。这样，同步脚本可以看到它自己的script元素和它们之前的文档内容</li>
<li>当解析器遇到设置了async和defer属性的script元素时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下来等它下载。异步脚本禁止使用document.write()方法。它们可以看到自己的script元素和它之前的所有文档元素，并且可能或干脆不可能访问其他的文档内容</li>
<li>当文档完成解析，document.readyState属性变成’interactive’</li>
<li>所有defer属性的脚本，会按它们在文档的里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用document.write()方法</li>
<li>浏览器在document对象上触发DOMContentLoaded事件。这标志着程序执行从同步脚本执行阶段转换到了异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成</li>
<li>这时，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，如图片。当所有这些内容完成加载时，并且所有异步脚本完成载入和执行，document.readyState属性改变为’complete’，web浏览器触发window对象上的load事件</li>
<li>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>时间线</tag>
      </tags>
  </entry>
  <entry>
    <title>dom基础</title>
    <url>/2018/05/28/js9/</url>
    <content><![CDATA[<p>这篇主要关于dom的一些基本知识，脚本化文档的内容，还包括一些window上的定时器方法</p>
<span id="more"></span>

<h5 id="什么是dom"><a href="#什么是dom" class="headerlink" title="什么是dom"></a>什么是dom</h5><ul>
<li><p>是Document Object Model的缩写，即文档对象模型。dom定义了表示和修改文档所需的对象、这些对象的行为和属性、这些对象之间的关系。是对html以及xml的标准编程接口</p>
</li>
<li><p>节点</p>
<ul>
<li>节点有四个属性<ol>
<li>nodeName 元素的标签名，以大写形式表示只读</li>
<li>nodeValue text节点或comment节点的文本内容，可读写</li>
<li>nodeType 该节点的类型，只读</li>
<li>attributes 节点的属性机顶盒</li>
</ol>
</li>
<li>节点的类型<ol>
<li>元素节点             1</li>
<li>属性节点             2</li>
<li>文本节点             3</li>
<li>注释节点             8</li>
<li>document             9 </li>
<li>DocumentFragment     11</li>
</ol>
</li>
<li>后面的数字是节点的 nodeType的值，通过这个值可以判断出节点的类型</li>
<li>节点的基本操作<ul>
<li>遍历节点树<br>  1.parentNode 2.childNodes 3.firstChild 4.lastChild 5.nextSibing 6.previousSibing</li>
<li>增加节点<br>  1.docuemnt.createElement() 2.document.createTextNode() 3.document.createComment() 4.document.createDocumentFragment()</li>
<li>插入节点<br>  1.parentnode.appendChild() 2.parentnode.insertBefore(a,b) a插到b前</li>
<li>删除节点<br>  parent.removeChild()</li>
<li>替换<br>  parent.replaceChild(new,origin)</li>
</ul>
</li>
<li>元素节点<br>  元素节点比较特殊，是我们主要操作的对象，它有一些其他节点没有的方法<ul>
<li>查看元素节点<ul>
<li>document代表整个文档</li>
<li>document.getElementById()  查找相应Id的元素，在IE8以下的浏览器不区分id大小写，而且也返回匹配name属性的元素</li>
<li>.getElementsByTageName() 按标签名匹配</li>
<li>.getElementsByName() 只有部分标签name可以匹配</li>
<li>.getElementsByClassName() 按类名匹配，ie8和ie8以下的ie中没有，可以同时多个class一起匹配</li>
<li>.querySelector()  css选择器，ie7和ie7之前没有，非实时，选出匹配的第一个元素</li>
<li>.querySelectorAll() css选择器，ie7和ie7之前没有，非实时，选出匹配的所有元素</li>
</ul>
</li>
<li>遍历元素节点<br>  1.parentElement（ie不兼容） 2.children 3.node.childElementCount &#x3D;&#x3D;&#x3D; node.children.length 子节点个数（ie不兼容） 4.firstElementChild 返回第一个子元素节点（ie不兼容） 5.lastElementChild 返回最后一个子元素节点（ie不兼容） 6.nextElementSibing&#x2F;previousElementSibing（ie不兼容）</li>
<li>元素节点的一些属性<ul>
<li>innerHTML </li>
<li>innerText(火狐不兼容)&#x2F;textContent(老版本ie不兼容)</li>
</ul>
</li>
<li>元素节点的一些方法<ul>
<li>.setAttribute()</li>
<li>.getAttribute()</li>
</ul>
</li>
</ul>
</li>
<li>dom元素节点上的一些属性<ul>
<li>查看元素的尺寸 dom.offsetWidth,dom.offsetHeight</li>
<li>查看元素的位置 dom.offsetLeft,dom.offsetTop 对于没有定位父级的元素，返回相对文档的坐标；对于有定位的父级元素，返回相对于最近的有定位的父级的坐标 dom.offsetParent 返回最近的有定位的父级</li>
</ul>
</li>
</ul>
</li>
<li><p>window上面的一些方法</p>
<ul>
<li>定时器（这个是window的方法）<ul>
<li>创建定时器<ul>
<li>var timer &#x3D; setInterval() 指定时间重复执行</li>
<li>var timer &#x3D; setTimerout() 指定时间执行一次</li>
</ul>
</li>
<li>删除定时器<ul>
<li>clearInterval(timer)</li>
<li>clearTimerout(timer)</li>
</ul>
</li>
<li>timer 的作用是为了删除的时候确定定时器</li>
</ul>
</li>
<li>查看滚动条的距离<ul>
<li>window.pageXOffset&#x2F;pageYOffset(ie8和ie8以下不兼容)</li>
<li>document.body&#x2F;documentElement.scrollLeft&#x2F;scrollTop 兼容性比较混乱，用的时候可以取两个值相加，因为这两个不同时有值，为了兼容封装兼容性的写法，代码如下  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getScrollOffset</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">pageXOffset</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">x</span>:<span class="variable language_">window</span>.<span class="property">pageXOffset</span>,</span><br><span class="line">            <span class="attr">y</span>:<span class="variable language_">window</span>.<span class="property">pageYOffset</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">x</span>:<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollLeft</span>+<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span>,</span><br><span class="line">            <span class="attr">y</span>:<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>+<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>查看视口的尺寸<ul>
<li>window.innerWidth&#x2F;innerHeight (ie8及ie8以下不兼容)</li>
<li>document.documentElement.clientWidth&#x2F;clientHeight (标准模式下，任意浏览器都兼容)</li>
<li>document.body.clientWidth&#x2F;clientHeight (适用于怪异模式下的浏览器)<br>  封装方法如下  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getViewportOffset</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="attr">width</span>:<span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">            <span class="attr">height</span>:<span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&#x27;CSS1Compat&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">width</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">            <span class="attr">height</span>:<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">width</span>:<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>,</span><br><span class="line">            <span class="attr">height</span>:<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>查看元素的几何尺寸<ul>
<li>ele.getBoundingClientRect() 兼容性很好，该方法返回一个对象，对象里面有left,top,right,bottom等属性，其中还有width,height属性，但在老版本ie中不支持，而且，这个返回值并不是实时的</li>
</ul>
</li>
<li>使滚动条滚动的方法<ul>
<li>scroll(),scrollTo(),scrollBy()</li>
<li>参数都是xy坐标，其中scrollBy方法是相对原来的位置进行的累加</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise迷你书</title>
    <url>/2022/06/19/promise%E8%BF%B7%E4%BD%A0%E4%B9%A6/</url>
    <content><![CDATA[<p><a href="http://liubin.org/promises-book/">中文版地址</a></p>
<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><ul>
<li>控制异步流程的对象</li>
<li>只能由<code>Pending</code>状态转换为<code>Fulfilled</code>和<code>Rejected</code>状态，状态不可逆</li>
<li>可以使用then方法进行接下来的处理回调</li>
</ul>
<h2 id="实战Promise"><a href="#实战Promise" class="headerlink" title="实战Promise"></a>实战Promise</h2><ul>
<li>Promise.resolve&#x2F;reject  包装生成promise实例</li>
<li>Promise#then <ul>
<li>then方法有两个参数，分别对应成功和失败的回调</li>
<li>return 可以进行值的传递。所传值都会由Promise.resolve进行包裹，保证传值为promise实例</li>
</ul>
</li>
<li>Promise#catch <ul>
<li>相当于then的特例，只有一个失败的回调</li>
<li>ie8 兼容问题 可以使用[‘catch’]去调用，避免保留字冲突；或者使用then方法去兼容</li>
</ul>
</li>
<li>Promise.all 当all中所有的promise对象都成功时调用then方法</li>
<li>Promise.race 当race中存在一个结束的promise时，调用then方法</li>
</ul>
<h2 id="Promise测试"><a href="#Promise测试" class="headerlink" title="Promise测试"></a>Promise测试</h2><ul>
<li>基于mocha对promise测试</li>
<li>普通的代码采用<code>then</code>→<code>catch</code>的流程的话比较容易理解</li>
<li>将测试代码集中到<code>then</code>中处理</li>
</ul>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><ul>
<li><p>Promise的实现类库</p>
<ul>
<li>Polyfill<ul>
<li><a href="https://github.com/stefanpenner/es6-promise">jakearchibald&#x2F;es6-promise</a></li>
<li><a href="https://github.com/YahooArchive/ypromise">yahoo&#x2F;ypromise</a></li>
<li><a href="https://github.com/getify/native-promise-only/">getify&#x2F;native-promise-only</a></li>
</ul>
</li>
<li>扩展类库<ul>
<li><a href="https://github.com/kriskowal/q">kriskowal&#x2F;q</a><ul>
<li>实现了 Promises 和 Deferreds 等规范，还提供了面向Node.js的文件IO API Q-IO 等</li>
</ul>
</li>
<li><a href="https://github.com/petkaantonov/bluebird">petkaantonov&#x2F;bluebird</a><ul>
<li>扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Promise.resolve 可以将thenable对象转化为promise对象，在不同的promise类库中转换可能需要thenable对象转化的操作</p>
</li>
<li><p>使用reject而不是throw，更安全</p>
</li>
<li><p>Deferred和Promise</p>
<ul>
<li><p>Deferred包含Promise</p>
</li>
<li><p>Deferred 具备对 Promise的状态进行操作的特权方法；即可以操控状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Deferred</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_resolve</span> = resolve;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_reject</span> = reject;</span><br><span class="line">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Deferred</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_resolve</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">promise</span>, value);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Deferred</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_reject</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">promise</span>, reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</li>
<li><p>使用Promise.race和delay取消XHR请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestMap = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createXHRPromise</span>(<span class="params">URL</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        req.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="variable constant_">URL</span>, <span class="literal">true</span>);</span><br><span class="line">        req.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.<span class="property">readyState</span> === <span class="title class_">XMLHttpRequest</span>.<span class="property">DONE</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> requestMap[<span class="variable constant_">URL</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(req.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(req.<span class="property">statusText</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(req.<span class="property">statusText</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.<span class="property">onabort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;abort this req&#x27;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.<span class="title function_">send</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    requestMap[<span class="variable constant_">URL</span>] = &#123;</span><br><span class="line">        <span class="attr">promise</span>: promise,</span><br><span class="line">        <span class="attr">request</span>: req</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">abortPromise</span>(<span class="params">promise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> request;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(requestMap).<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">URL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestMap[<span class="variable constant_">URL</span>].<span class="property">promise</span> === promise) &#123;</span><br><span class="line">            request = requestMap[<span class="variable constant_">URL</span>].<span class="property">request</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (request != <span class="literal">null</span> &amp;&amp; request.<span class="property">readyState</span> !== <span class="title class_">XMLHttpRequest</span>.<span class="property">UNSENT</span>) &#123;</span><br><span class="line">        request.<span class="title function_">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; </span><br><span class="line">    createXHRPromise,</span><br><span class="line">    abortPromise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>done 方法(非规范，为类库实现)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">done</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">then</span>(onFulfilled, onRejected).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">           <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> error;</span><br><span class="line">           &#125;, <span class="number">0</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>done 方法不会返回promise</p>
</li>
<li><p>done 方法的异常会直接抛到外面</p>
</li>
</ul>
</li>
<li><p>Promise方法链</p>
<ul>
<li><p>Promisification可以转化</p>
</li>
<li><p>Promise并不是总是异步编程的最佳选择</p>
</li>
<li><p>某些情况可以使用promise做一层封装，可以便于操作理解等</p>
</li>
</ul>
</li>
<li><p>使用Promise进行顺序（sequence）处理</p>
</li>
</ul>
<h2 id="Promises-API-Reference"><a href="#Promises-API-Reference" class="headerlink" title="Promises API Reference"></a>Promises API Reference</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise#then</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line"><span class="comment">// Promise#catch</span></span><br><span class="line">promise.<span class="title function_">catch</span>(onRejected);</span><br><span class="line"><span class="comment">// Promise.resolve</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(object);</span><br><span class="line"><span class="comment">// Promise.reject</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(object)</span><br><span class="line"><span class="comment">// Promise.all</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promiseArray);</span><br><span class="line"><span class="comment">// Promise.race</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(promiseArray);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2018/06/03/reg/</url>
    <content><![CDATA[<p>正则表达式基础学习</p>
<span id="more"></span>

<h5 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h5><pre><code>1. var reg = /pattern/;
2. var reg = new RegExp(&#39;pattern&#39;);
</code></pre>
<h6 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h6><table>
<thead>
<tr>
<th>字符</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>[…]</td>
<td>方括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在方括号内的任意字符</td>
</tr>
<tr>
<td>.</td>
<td>除换行符和其他Unicode行终止符之外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>任何ASCII字符组成的单词，等价于[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\W</td>
<td>任何非ASCII字符组成的单词，等价于[^a-zA-Z0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>任何Unicode空白符</td>
</tr>
<tr>
<td>\S</td>
<td>任何非Unicode空白符的字符</td>
</tr>
<tr>
<td>\d</td>
<td>任何ASCII数字，等价于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>除了ASCII数字之外的任何字符，等价于[^0-9]</td>
</tr>
<tr>
<td>[\b]</td>
<td>退格直接量（特例）</td>
</tr>
</tbody></table>
<h6 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h6><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>{n,m}</td>
<td>匹配前一项至少n次，但不超过m次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前一项n次或者更多次</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配前一项n次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一项1次或多次，等价于{1,}</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一项0次或多次，等价于{0,}</td>
</tr>
</tbody></table>
<p>非贪婪的重复：上面的重复匹配字符是尽可能多的匹配字符，这种成为贪婪的重复，如果需要尽可能少的匹配，这种称为非贪婪的重复，只需要在待匹配的字符后面加一个?即可，有的时候会有一些与期望不同的情况，所以在实际使用的时候注意正则匹配的原理，它是从开头进行匹配的，不会进行跳跃</p>
<h6 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h6><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;#124;</td>
<td>选择，匹配的是该符号左边的子表达式或右边的子表达式</td>
</tr>
<tr>
<td>(…)</td>
<td>组合，将集合项合并成一个单元，可用过’*’、’+’、’?’和’&amp;#124;’等符号加以修饰，而且可以记住这个匹配的字符，供后面的引用使用</td>
</tr>
<tr>
<td>(?:…)</td>
<td>只组合，与上面的基本相同，唯一的区别是不会记忆匹配的字符，后面无法引用</td>
</tr>
<tr>
<td>\n</td>
<td>引用，和前面的(…)一起使用，找和第n和括号匹配的记忆字符，注意查第几个的时候以左括号为基准</td>
</tr>
</tbody></table>
<h6 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h6><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界的位置</td>
</tr>
<tr>
<td>(?&#x3D;p)</td>
<td>零宽正向先行判断，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符（匹配结果不包括p）</td>
</tr>
<tr>
<td>(?!p)</td>
<td>零宽负向先行判断，要求接下来的字符不与p匹配</td>
</tr>
</tbody></table>
<h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>执行不区分大小写的匹配</td>
</tr>
<tr>
<td>g</td>
<td>执行一个全局匹配</td>
</tr>
<tr>
<td>m</td>
<td>多行匹配</td>
</tr>
</tbody></table>
<h5 id="用于匹配的string方法"><a href="#用于匹配的string方法" class="headerlink" title="用于匹配的string方法"></a>用于匹配的string方法</h5><ul>
<li>search()     参数为正则表达式，返回匹配成功的子串的起始位置，否则返回-1，不支持g，默认忽略</li>
<li>replace()    有两个参数，第一个为匹配的正则表达式，第二个为要替换成的字符串，可以为’$’+数字，与正则表达式中的引用相同，只不过这里用’&amp;’而不是’&#39;，第二个参数也可以是一个函数，必须有一个返回值，返回值为替换的值，这个函数的参数为匹配成功的字符串</li>
<li>match()      返回值为一个数组，其中，当参数正则表达式执行的不是全局检索（g）时，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且只返回第一个匹配成功的；否则，会返回所有满足正则表达式的元素构成的数组，不返回括号中的子表达式    </li>
<li>split()      该方法把字符串按照参数拆分成数组，参数可以为正则表达式</li>
</ul>
<h5 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h5><ul>
<li>属性<br> global：是否有g属性    ignoreCase：是否有i属性      multiline：是否有m属性     lastIndex：最后匹配的字符位置（注意，在一些匹配的时候需要重置）      source：对应正则表达式的源文本</li>
<li>方法</li>
<li>exec()   返回值为一个数组，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且只返回第一个匹配成功的，返回值有index（发生匹配的位置）和input（正在检索的字符串）属性，当同一个正则表达式再次调用的时候，会从lastIndex继续检索，返回值相同，当没有匹配结果的时候，lastIndex重置为0</li>
<li>test()  判断时候匹配，成功返回true，否则返回false</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>js</tag>
        <tag>reg</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2018/04/09/test/</url>
    <content><![CDATA[<blockquote>
<p>这是一个引用<br>这是啥呢</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<blockquote class="pullquote [class]"><p>content 这是个啥</p>
</blockquote>

<span id="more"></span>
<h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<ol>
<li>有序1</li>
<li>有序2</li>
</ol>
<ul>
<li>强调？？？？</li>
</ul>
<p><a href="www.baidu.com">百度</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/30/1600d3b566694bdb?w=96&h=96&f=png&s=867" alt="简书"></p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>内容</td>
</tr>
<tr>
<td>内容</td>
<td>内容</td>
</tr>
</tbody></table>
<p>在第二行中的-为对齐方式，默认为左对齐，右面加：为右对齐，左右两面加：为居中</p>
<p>表格中天机竖线可以使用&amp;#124;其他也可以进行 124为十进制的ASCII竖线对应的码值</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js(一)</title>
    <url>/2022/06/04/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js1/</url>
    <content><![CDATA[<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
作用域与闭包</p>
</li>
<li><p><input disabled="" type="checkbox"> 
this与对象原型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
类型与文法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
异步与性能</p>
</li>
<li><p><input disabled="" type="checkbox"> 
ES6与未来</p>
<span id="more"></span></li>
</ul>
<h1 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h1><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><ul>
<li><p>编译器，是先进行编译，然后去运行的</p>
</li>
<li><p>作用域是通过标识符号名称查询变量的一组规则</p>
</li>
<li><p>LHS和RHS 个人理解RHS是需要知道变量的值 LHS是需要知道变量的容器</p>
</li>
</ul>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><ul>
<li><p>词法分析时进行定义的，意味着在你定义一个函数的时候就决定了它的作用域</p>
</li>
<li><p>欺骗词法作用域</p>
<ul>
<li>evel  执行字符串，就好像原来就在这个位置上一样</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="title function_">evel</span>(str)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="string">&#x27;var b = 3&#x27;</span>, <span class="number">1</span>) <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>with 在运行时把传入对象作为作用域去使用，需要注意的是，如果对象没有这个，就会导致全局的变量声明</li>
<li>上面两者的缺点是，无法提前知道内容是什么，导致引擎做的优化全部失效，会有性能问题</li>
</ul>
<h2 id="函数与块作用域"><a href="#函数与块作用域" class="headerlink" title="函数与块作用域"></a>函数与块作用域</h2></li>
<li><p>函数作用域，每声明一个函数，每一个函数就会生成一个自己的作用域</p>
</li>
<li><p>在函数内定义函数，去隐藏作用域</p>
<ul>
<li><p>避免冲突 </p>
</li>
<li><p>全局名称空间</p>
</li>
<li><p>模块管理</p>
</li>
</ul>
</li>
<li><p>函数作为作用域 利用立即执行函数去隐藏</p>
</li>
<li><p>块作为作用域 </p>
<ul>
<li><p>with</p>
</li>
<li><p>try&#x2F;catch 在catch子句上拥有块作用域</p>
</li>
<li><p>let&#x2F;const 劫持{}生成块作用域</p>
</li>
<li><p>使用块作用域可以更好的做垃圾回收</p>
</li>
<li><p>let 解决 for 循环</p>
</li>
</ul>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2></li>
<li><p>函数优先 重复函数声明，后面的会覆盖前面的</p>
</li>
</ul>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><ul>
<li><p>闭包：函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域之外执行时</p>
</li>
<li><p>模块</p>
<ul>
<li><p>利用闭包可以实现一个简单的模块加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyModules</span> = (<span class="keyword">function</span> <span class="title function_">Manager</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">define</span>(<span class="params">name, deps, impl</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            deps[i] = impl.<span class="title function_">apply</span>(impl, deps)</span><br><span class="line">        &#125;</span><br><span class="line">          modules[name] = impl.<span class="title function_">apply</span>(impl, deps)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define,</span><br><span class="line">        get</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()    </span><br></pre></td></tr></table></figure>
</li>
<li><p>es6模块</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js(三)</title>
    <url>/2022/06/06/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js3/</url>
    <content><![CDATA[<ul>
<li><p><input disabled="" type="checkbox"> 
作用域与闭包</p>
</li>
<li><p><input disabled="" type="checkbox"> 
this与对象原型</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
类型与文法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
异步与性能</p>
</li>
<li><p><input disabled="" type="checkbox"> 
ES6与未来</p>
<span id="more"></span>

<h1 id="类型与文法"><a href="#类型与文法" class="headerlink" title="类型与文法"></a>类型与文法</h1></li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>内建类型 <code>null</code> <code>undefined</code> <code>boolean</code> <code>number</code> <code>string</code> <code>object</code> <code>symbol</code> <code>bigInt</code></li>
<li>对于未定义的变量判断，使用typeof的安全防卫机制（防止一个错误）是有用的</li>
</ul>
<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><ul>
<li><p>array</p>
<ul>
<li>不建议使用string作为key</li>
</ul>
</li>
<li><p>类array</p>
<ul>
<li>Array.prototype.slice.call </li>
<li>Array.from</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li>可以通过Array.prototype.join.call去调用数组方法处理字符串</li>
</ul>
</li>
<li><p>number</p>
<ul>
<li><p>小数值判断：Number.EPSILON 最小的一个容差，如果小于就认为是相等的</p>
</li>
<li><p>判断整数：Number.isInteger</p>
</li>
<li><p>undefined 在非严格情况下可以作为变量名进行赋值操作，可以通过void 0 获取一个安全的undefined</p>
</li>
<li><p>NaN 唯一一个不等于本身的数</p>
<ul>
<li>全局的isNaN判断是转换成number类型进行判断的</li>
<li>Number.isNaN 可以进行判断</li>
</ul>
</li>
<li><p>无穷 可以变成无穷，但是不可以反操作， Infinity&#x2F; Infinity 为NaN</p>
</li>
<li><p>零 +0 -0 0</p>
<ul>
<li>&#x3D;&#x3D; 或&#x3D;&#x3D;&#x3D; 时都是相等的</li>
</ul>
</li>
<li><p>特殊等价 Object.is 忽略前面的，符合一般的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">is</span> = <span class="keyword">function</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>) &#123; <span class="comment">// 判断-1的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/v1 === <span class="number">1</span>/v2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v1 !== v1) &#123; <span class="comment">// 判断NaN的情况</span></span><br><span class="line">        <span class="keyword">return</span> v2 !== v2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v1 === v2 <span class="comment">// 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>值与引用</p>
<ul>
<li>需要注意是否使用的引用，需要注意出现的更改影响范围</li>
</ul>
</li>
</ul>
<h2 id="原生类型（内建类型）"><a href="#原生类型（内建类型）" class="headerlink" title="原生类型（内建类型）"></a>原生类型（内建类型）</h2><ul>
<li><p>也就是js内常用的构建函数</p>
</li>
<li><p>typeof 结果通常为object 需要通过Object.prototype.toString.call 的返回值去判断具体类型</p>
</li>
<li><p>包装类 需要注意故意包装的类型是object 如果判断结果一定是true</p>
</li>
<li><p>开箱 valueof </p>
</li>
<li><p>Array 需要注意各种生成空值数组的情况，不建议使用</p>
</li>
<li><p>Function.prototype 是一个函数 RegExp.prototype 是一个正则表达式 Array.prototype 是一个数组</p>
</li>
</ul>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ul>
<li>抽象值操作<ul>
<li>ToString null &#x3D;&gt; ‘null’ undefined &#x3D;&gt; ‘undefined’ true &#x3D;&gt; ‘true’<ul>
<li>JSON.stringify 遇到undefined function symbol 会忽略 如果在array中会转换为null 如果遇到循环引用会报错， 内部实际调用了toJSON的方法，string number boolean null 调用的结果与tostring相同</li>
</ul>
</li>
<li>ToNumber<ul>
<li>string类型是希望转换为数字，如果不可以就为NaN</li>
<li>对象会 ToPrimitive操作 执行valueof（如果有，并且返回为基本类型） 然后去执行toString，都没有就会报错，然后toNumber</li>
</ul>
</li>
<li>ToBoolean</li>
<li>转为false的值为：<code>undefined</code> <code>null</code> <code>+0/-0/NaN</code> <code>false</code> <code>&#39;&#39;</code>, 其余都为true</li>
</ul>
</li>
<li>明确的类型转换<ul>
<li>+转换字符串为数字 ～转换-1为0 ，～x &#x3D; -(x+1) ～～截取整数</li>
<li>parseInt 建议一直写第二个参数为10，防止判断为其他进制, 如果传入的不是string类型的参数，则会toString 然后再去执行操作</li>
</ul>
</li>
<li>隐含的类型转换<ul>
<li>string &lt;–&gt; number<ul>
<li>+求和时： 如果其中有一个为string 则变成string相加，其他类型会ToPrimitive然后相加</li>
</ul>
</li>
<li>symbol<ul>
<li>可以通过String转换为字符串，但是不可以用+’’去转换</li>
</ul>
</li>
<li>&#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; &#x3D;&#x3D;允许类型转换 &#x3D;&#x3D;&#x3D; 不允许<ul>
<li>类型相同，直接比较，如果是引用类型，比较引用是否相同</li>
<li>string与number比较，toNumber后进行比较</li>
<li>boolean与其他类型比较，toNumber（boolean）然后进行比较</li>
<li>null 与 undefine 为 true 和其他值比较为false</li>
<li>object与其他比较 toPrimitive后进行比较</li>
</ul>
</li>
<li>比较大小时，如果有一个为number，另一个会 会toPriitive 然后执行toNumber， 如果都为字符串，则按字符比较</li>
</ul>
</li>
</ul>
<h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><ul>
<li>语句与表达式<ul>
<li>js中 语句为句子 表达式为短语</li>
</ul>
</li>
<li>语句完成值，就是语句结束在控制台上可以看到的值</li>
<li>[] + {} 与 {} + []<ul>
<li>[] + {} &#x3D;&gt; ‘’ + ‘[object Object]’  &#x3D;&gt; ‘[object Object]’ 其中 {} 为 空对象</li>
<li>{} + [] &#x3D;&gt; + []  &#x3D;&gt; + ‘’ &#x3D;&gt; 0 其中{} 为一个空的代码块</li>
</ul>
</li>
<li>else if  其实并不存在 else{ if }</li>
<li>&amp;&amp; 比 ||优先级高</li>
<li>加不加分号<ul>
<li>建议是，尽可能的加分号</li>
</ul>
</li>
<li>暂时性死区<ul>
<li>typeof 也是一样会报错</li>
</ul>
</li>
<li>函数参数，不要即用参数变量又用argument的值，会产生歧义<ul>
<li>非严格模式下，如果传入参数，参数变量修改会映射到argument上，否则不会</li>
<li>严格模式下，参数变量修改不会影响argument</li>
</ul>
</li>
<li>try…finally 会执行try，然后执行finally 最后如果是函数返回，才会继续执行</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js(二)</title>
    <url>/2022/06/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js2/</url>
    <content><![CDATA[<ul>
<li><p><input disabled="" type="checkbox"> 
作用域与闭包</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
this与对象原型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
类型与文法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
异步与性能</p>
</li>
<li><p><input disabled="" type="checkbox"> 
ES6与未来</p>
<span id="more"></span></li>
</ul>
<h1 id="this与对象原型"><a href="#this与对象原型" class="headerlink" title="this与对象原型"></a>this与对象原型</h1><h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><ul>
<li>this是运行时绑定的，依赖于函数调用的上下文条件，与定义无关，与函数调用的方式有关，执行环境的活动记录中存在this的引用</li>
</ul>
<h2 id="this豁然开朗"><a href="#this豁然开朗" class="headerlink" title="this豁然开朗"></a>this豁然开朗</h2><ul>
<li>如何判定this<ul>
<li>函数是否是通过new调用，如果是，this就是新构建的对象</li>
<li>call&#x2F;apply绑定，this为绑定的对象</li>
<li>对象调用，this为调用的对象</li>
<li>默认绑定，如果是严格模式为undefined，否则为global对象</li>
</ul>
</li>
<li>绑定的特例<ul>
<li>如果null&#x2F;undefined作为call&#x2F;apply&#x2F;bind的this，那么会忽略掉</li>
<li>(p.foo &#x3D; o.foo)() 如此间接调用会采用默认调用</li>
<li>词法this 箭头函数，只与定义时候的环境有关</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>属性名为字符串或Symbol</li>
<li>对象的拷贝<ul>
<li>浅拷贝 复制对于value的引用</li>
<li>深拷贝 复制value引用的内容</li>
</ul>
</li>
<li>属性描述符<ul>
<li>value 值</li>
<li>writable 可写性</li>
<li>enumerable 可枚举性</li>
<li>configurable 可配置性</li>
</ul>
</li>
<li>对象的不可变性实现<ul>
<li>对象常量 writable+configurable &#x3D; false </li>
<li>防止扩展 Object.preventExtensions</li>
<li>封印Seal configurable &#x3D; false +防止扩展 Object.seal</li>
<li>冻结Freeze  封印+对象常量</li>
</ul>
</li>
<li>对象的存在性<ul>
<li>in  是否存在于对象及原型链中</li>
<li>hasOwnProperty 是否存在于对象中</li>
<li>枚举 对象的属性在迭代时是否会包含在内<ul>
<li>区分 propertyIsEnumerable</li>
<li>Object.keys 返回所有可枚举属性数组 针对当前对象</li>
<li>Object.getOwnPropertyNames 返回所有属性的数组包括不可枚举的类型 针对当前对象</li>
</ul>
</li>
</ul>
</li>
<li>迭代<ul>
<li>定义对象的Symbol.iterator可以使对象可以调用迭代的方法如for of</li>
</ul>
</li>
</ul>
<h2 id="混合类的对象"><a href="#混合类的对象" class="headerlink" title="混合类的对象"></a>混合类的对象</h2><ul>
<li>js中不存在类，类是一种设计模式，在js中可以去模拟类，会存在拷贝的问题</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li>设置与遮蔽属性<ul>
<li>1 如果在原型链中并且可以writable 则会在原对象中创建赋值</li>
<li>2 如果writable：false 则忽略赋值操作</li>
<li>3 如果在原型链中找到并且是setter 则调用setter，不会在原对象中进行操作</li>
<li>如果遇到上面2&#x2F;3的情况，则需要使用Object.defineProperty 去添加属性</li>
</ul>
</li>
<li>fn.isPrototypeOf(a) 判断a是否是fn的实例 getPrototypeOf() 获取原型链</li>
</ul>
<h2 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h2><ul>
<li>实际上就是利用原型链进行方法的继承管理，是一种没有类的抽象，基于原型链的行为委托</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js(四)</title>
    <url>/2022/06/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js4/</url>
    <content><![CDATA[<ul>
<li><p><input disabled="" type="checkbox"> 
作用域与闭包</p>
</li>
<li><p><input disabled="" type="checkbox"> 
this与对象原型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
类型与文法</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
异步与性能</p>
</li>
<li><p><input disabled="" type="checkbox"> 
ES6与未来</p>
<span id="more"></span></li>
</ul>
<h1 id="异步与性能"><a href="#异步与性能" class="headerlink" title="异步与性能"></a>异步与性能</h1><h2 id="异步：现在与稍后"><a href="#异步：现在与稍后" class="headerlink" title="异步：现在与稍后"></a>异步：现在与稍后</h2><ul>
<li>js程序的执行是按照代码块的，会通过队列去顺序执行，任何一个时刻，都只会执行一个代码块</li>
</ul>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><ul>
<li><p>存在回调地狱的问题</p>
</li>
<li><p>存在控制反转的问题</p>
</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul>
<li>重新定义了毁掉的安排方式，定义了一种异步流程的方式，具体的api使用建议还是看阮一峰的es6吧</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul>
<li><p>是一个新的函数类型，可以控制调用时机，为异步代码保留了顺序的、同步的、阻塞的代码模式，便于理解</p>
</li>
<li><p>通过结合Generator和Promise，可以实现强大的异步调用方式，也就是async await</p>
</li>
</ul>
<h2 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h2><ul>
<li><p>web worker</p>
<ul>
<li><p>worker环境 不能访问主程序的资源，是完全分离的线程，可以引入其他的js</p>
</li>
<li><p>适合用途：处理密集型数学运算、大数据集合的排序、数据操作、高流量网络通信</p>
</li>
<li><p>数据传输</p>
<ul>
<li>使用transferable对象做数据专递，减少传输对象的拷贝</li>
</ul>
</li>
<li><p>共享的workers</p>
<ul>
<li>sharedworker 多标签页共享的worker</li>
</ul>
</li>
</ul>
</li>
<li><p>SIMD 提议将cpu级别的并行数学操作映射到js的api上以提高计算效率</p>
</li>
<li><p>asm.js 通过规范使js代码的运行得到一定的优化</p>
<ul>
<li><p>如何使用其进行优化：通过提示跳过强制转换最终</p>
</li>
<li><p>本意是针对一种特定的任务的优化方式，如密集数学操作</p>
</li>
<li><p>意图是作为一个虫其他高度优化的程序语言交叉编译来的目标</p>
</li>
</ul>
</li>
</ul>
<h2 id="基准分析与调优"><a href="#基准分析与调优" class="headerlink" title="基准分析与调优"></a>基准分析与调优</h2><ul>
<li><p>基准分析</p>
<ul>
<li><p>Benchmark.js 基准分析工具</p>
</li>
<li><p>jsPerf.com 使用benchmark.js的网站，可以针对不同上下文和环境进行测试</p>
</li>
</ul>
</li>
<li><p>调优</p>
<ul>
<li><p>要从大局出发，在关键路径上进行优化，避免落入不同js引擎的实现细节的陷阱</p>
</li>
<li><p>尾部调用优化：在函数的最后使用其他函数的直接返回值，可以突破递归调用的一些限制</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js(五)</title>
    <url>/2022/06/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js5/</url>
    <content><![CDATA[<ul>
<li><p><input disabled="" type="checkbox"> 
作用域与闭包</p>
</li>
<li><p><input disabled="" type="checkbox"> 
this与对象原型</p>
</li>
<li><p><input disabled="" type="checkbox"> 
类型与文法</p>
</li>
<li><p><input disabled="" type="checkbox"> 
异步与性能</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
ES6与未来</p>
<span id="more"></span>

<h1 id="ES6与未来"><a href="#ES6与未来" class="headerlink" title="ES6与未来"></a>ES6与未来</h1></li>
</ul>
<h2 id="ES？现在与未来"><a href="#ES？现在与未来" class="headerlink" title="ES？现在与未来"></a>ES？现在与未来</h2><ul>
<li>因为兼容性问题，新语法需要转译和填补</li>
<li>对于新的语法，要去多学习😂</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>块作用域</p>
<ul>
<li><p>let、const声明</p>
</li>
<li><p>可能存在的问题，如果在if&#x2F;else中去声明函数的化，可能会存在作用域不同的情况</p>
</li>
</ul>
</li>
<li><p>rest操作符</p>
</li>
<li><p>默认参数</p>
</li>
<li><p>默认表达式</p>
</li>
<li><p>解构赋值</p>
<ul>
<li>如果对已经声明的变量进行解构，需要在()中进行</li>
</ul>
</li>
<li><p>对象字面量扩展</p>
<ul>
<li><p>简约属性</p>
</li>
<li><p>简约方法</p>
</li>
<li><p>getter&#x2F;setter</p>
</li>
<li><p>计算型属性名</p>
</li>
<li><p>设置原型链 setPrototypeOf</p>
</li>
<li><p>super可用，对象可以找到原型链上进行操作</p>
</li>
</ul>
</li>
<li><p>模板字面量</p>
<ul>
<li><p>原始字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showraw</span>(<span class="params">strings, ...values</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strings)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strings.<span class="property">raw</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showraw<span class="string">`Hellow\nWorld`</span></span><br><span class="line"><span class="comment">// [&#x27;Hellow\nWorld&#x27;, raw: Array(1)]</span></span><br><span class="line"><span class="comment">// [&#x27;Hellow\\nWorld&#x27;]</span></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>总是函数表达式</p>
</li>
<li><p>this指向不同，为定义时所在的上下文</p>
</li>
</ul>
</li>
<li><p>for of 循环</p>
<ul>
<li>可以遍历一组由迭代器生产的值</li>
</ul>
</li>
<li><p>正则表达式扩展</p>
<ul>
<li><p>unicode标志</p>
</li>
<li><p>粘性标志y</p>
</li>
<li><p>flags 获取标志位</p>
</li>
</ul>
</li>
<li><p>数字字面量扩展</p>
<ul>
<li>不同进制</li>
</ul>
</li>
<li><p>Unicode</p>
<ul>
<li><p>敏感的字符串操作 normalize 正规化操作，可用于判断长度等</p>
</li>
<li><p>可以声明unicode变量名</p>
</li>
</ul>
</li>
<li><p>symbol</p>
<ul>
<li>获取作为对象属性 getOwnPropertySymbols</li>
</ul>
</li>
</ul>
<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><ul>
<li><p>迭代器</p>
</li>
<li><p>generator</p>
</li>
<li><p>模块</p>
<ul>
<li><p>过去使用函数进行模块的划分</p>
</li>
<li><p>现在使用es6的import就可以原生支持模块化</p>
</li>
</ul>
</li>
<li><p>类</p>
<ul>
<li><p>class</p>
<ul>
<li><p>必须与new一起使用</p>
</li>
<li><p>不会声明提升</p>
</li>
<li><p>super是静态绑定的，不会改变</p>
</li>
<li><p>static symbol.species 指定 构造器</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异步流程控制"><a href="#异步流程控制" class="headerlink" title="异步流程控制"></a>异步流程控制</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li><p>类型化数组 二进制类型</p>
</li>
<li><p>Map&#x2F;WeakMap&#x2F;Set&#x2F;WeakSet</p>
</li>
</ul>
<h2 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h2><ul>
<li><p>Array</p>
<ul>
<li><p>Array.of 生成一个数组无逻辑负担</p>
</li>
<li><p>Array.from 转换为一个数组， 第二个参数可以转换生成数组的值</p>
</li>
<li><p>copyWithin 数组原型方法（目标， 开始， 结束）</p>
</li>
<li><p>fill 填充（value） &#x2F; （value， 开始， 结束）</p>
</li>
<li><p>find&#x2F;findIndex 调用函数，返回true就返回结果</p>
</li>
<li><p>entries values keys</p>
</li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li><p>is 严格判断是否相等 NaN 和 NaN相等 0 与 -0不等</p>
</li>
<li><p>getOwnPropertySymbols 获取key中的symbol</p>
</li>
<li><p>setPrototypeOf 设置原型链</p>
</li>
<li><p>assign 合并对象 可枚举的和symbol可以被拷贝</p>
</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li><p>三角函数</p>
</li>
<li><p>算数函数</p>
</li>
<li><p>元函数</p>
<ul>
<li>sign 返回数字的符号</li>
</ul>
</li>
</ul>
</li>
<li><p>Number</p>
<ul>
<li><p>静态属性</p>
<ul>
<li><p>EPSILON 最小值</p>
</li>
<li><p>MAX_SAFE_INTEGER 最大安全整数</p>
</li>
<li><p>MIN_SAFE_INTEGER 最小安全整数</p>
</li>
</ul>
</li>
<li><p>isNaN 如果不是nunber 返回true 如果是，判断是否是NaN</p>
</li>
<li><p>isInteger 判断是否是整数</p>
</li>
</ul>
</li>
<li><p>String</p>
<ul>
<li><p>unicode函数</p>
<ul>
<li>fromCodePoint &#x2F; codePointAt &#x2F; normalize</li>
</ul>
</li>
<li><p>raw</p>
</li>
<li><p>repeat 重复</p>
</li>
<li><p>startsWith&#x2F;endsWith&#x2F;includes</p>
</li>
</ul>
</li>
</ul>
<h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><ul>
<li><p>元编程：针对程序本身的行为进行编程的编程</p>
</li>
<li><p>函数名推断 function.name</p>
</li>
<li><p>元属性 new.target</p>
</li>
<li><p>通用Symbol</p>
<ul>
<li><p>iterator</p>
</li>
<li><p>toStringTag&#x2F;hasInstance toStringTag 改变[object –] 可以替换–的展示</p>
</li>
<li><p>species 构造器</p>
</li>
<li><p>toPrimitive 抽象强制转换操作</p>
</li>
<li><p>正则表达式</p>
<ul>
<li><p>match</p>
</li>
<li><p>replace</p>
</li>
<li><p>search</p>
</li>
<li><p>split</p>
</li>
</ul>
</li>
<li><p>isConcatSpreadable concat的时候是否被展开</p>
</li>
<li><p>unscopables 是否可以在with中暴露</p>
</li>
</ul>
</li>
<li><p>代理 proxy</p>
<ul>
<li><p>get&#x2F;set</p>
</li>
<li><p>deleteProperty</p>
</li>
<li><p>apply</p>
</li>
<li><p>construct</p>
</li>
<li><p>getOwnpropertyDescriptor</p>
</li>
<li><p>defineProperty</p>
</li>
<li><p>getPrototypOf&#x2F;setPrototypeOf</p>
</li>
<li><p>preventExtensions</p>
</li>
<li><p>isExtensible</p>
</li>
<li><p>ownKeys</p>
</li>
<li><p>enumerate</p>
</li>
<li><p>has </p>
</li>
<li><p>有些操作无法拦截 typeof String(obj) obj+’’ obj &#x3D;&#x3D; pobj obj &#x3D;&#x3D;&#x3D; pobj</p>
</li>
<li><p>可撤销代理 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">proxy</span>: pobj, <span class="attr">revoke</span>: prevoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(obj, handlers)</span><br><span class="line"><span class="title function_">prevoke</span>() <span class="comment">// 撤销代理</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Reflect </p>
<ul>
<li><p>ownKeys 可以获取所有直属的key的列表</p>
</li>
<li><p>enumrate 获取所有包括继承的非symbol、可枚举的值的迭代器</p>
</li>
</ul>
</li>
<li><p>属性顺序 [[OwnPropertyKeys]] es6中 目前对ownKeys&#x2F;getOwnPropertyNames&#x2F;getOwnPropertySymbols有保证</p>
<ul>
<li><p>数字上升，数字属性名</p>
</li>
<li><p>以创建顺序枚举直属字符串属性名</p>
</li>
<li><p>以创建顺序枚举直属symbol属性</p>
</li>
</ul>
</li>
<li><p>特性测试</p>
<ul>
<li>featureTests.io</li>
</ul>
</li>
<li><p>尾部调用优化</p>
<ul>
<li><p>可以通过蹦床</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trampoline</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        res = <span class="title function_">res</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归展开，变成循环</p>
</li>
<li><p>try catch 捕获去判断，去自我调整</p>
</li>
</ul>
</li>
</ul>
<h2 id="ES6以后"><a href="#ES6以后" class="headerlink" title="ES6以后"></a>ES6以后</h2><ul>
<li><p>async await</p>
</li>
<li><p>Object.observe()</p>
</li>
<li><p>… 扩展对象属性</p>
</li>
<li><p>指数操作符</p>
</li>
<li><p>Array.includes</p>
</li>
<li><p>SIMD</p>
</li>
<li><p>WebAssembly(WASM)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端登陆方式</title>
    <url>/2022/06/18/%E5%89%8D%E7%AB%AF%E7%99%BB%E9%99%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/images/%E5%89%8D%E7%AB%AF%E7%99%BB%E9%99%86%E6%96%B9%E5%BC%8F.png" alt="前端登陆方式"></p>
]]></content>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全</title>
    <url>/2022/06/16/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><img src="/images/%E5%AE%89%E5%85%A8.png" alt="前端安全"></p>
]]></content>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域</title>
    <url>/2022/06/17/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><img src="/images/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F.png" alt="前端安全"></p>
]]></content>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>骨架屏插件</title>
    <url>/2022/06/21/%E9%AA%A8%E6%9E%B6%E5%B1%8F%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li><p>骨架屏插件</p>
<ul>
<li>借鉴<a href="https://github.com/Jocs/jocs.github.io/issues/22">page-skeleton-webpack-plugin</a>,开发一个vite版插件，暂时未发布</li>
</ul>
</li>
<li><p>插件实现逻辑</p>
<ul>
<li>init阶段<ul>
<li>插件初始化，生成可接收的本地服务器响应server，初始化socket(连接client中sockjs，并初始化响应代码)，响应操作，初始化skeleton对象(操作浏览器视图，及转换)</li>
<li>vite transformIndexHtml 生命周期中添加script脚本（该脚本可在初始化服务器中响应）</li>
</ul>
</li>
<li>运行阶段<ul>
<li>加载添加的script脚本</li>
<li>server响应，加载到client中的代码，可以响应<code>toggleBar</code></li>
<li>通过浏览器控制台输入<code>toggleBar</code>,调用client中代码，执行操作，显示html</li>
<li>点击html中的显示编辑页面，通过SockJS触发sock.send操作</li>
<li>响应sockjs,调用skeleton操作，并把页面数据写入sockjs中，最后打开preview页面(编辑页面)</li>
<li>preview页面获取前面的页面链接，并读取sockjs中的数据，利用iframe分别展示正常页面和骨架屏页面，及代码页面</li>
<li>点击写入按钮，可以生成骨架屏html文件</li>
</ul>
</li>
<li>待完成<ul>
<li>在build阶段可以骨架屏html替换 <code>&lt;!-- shell --&gt;</code> 注释，生成最后代码</li>
</ul>
</li>
</ul>
</li>
<li><p>Skeleton 主要逻辑</p>
<ul>
<li>利用puppeteer控制浏览器</li>
<li>利用puppeteer获取页面,通过api调用page，并插入script代码（script&#x2F;index中Skeleton，为转化标签的代码），并执行，生成骨架代码，写入内存中，等编辑页请求时返回</li>
</ul>
</li>
</ul>
<p><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&version=v14.4.1&show=api-class-puppeteer">puppeteer中文文档</a></p>
]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>理解OAuth</title>
    <url>/2022/07/19/%E7%90%86%E8%A7%A3OAuth/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>OAuth 是一个关于授权的开放网络标准，目前版本为2.0，用来授权第三方应用，获取用户数据。简单来说就是给第三方令牌的过程</p>
<h3 id="OAuth流程"><a href="#OAuth流程" class="headerlink" title="OAuth流程"></a>OAuth流程</h3><p>数据所有者告诉系统，统一授权第三方应用进入系统，获取这些数据。系统产生一个短期的进入令牌，用来替代密码，供第三方使用</p>
<ul>
<li>令牌与密码的对比<ul>
<li>令牌是短期的，到期会自动生效</li>
<li>令牌可以被数据所有者撤销，会立即生效</li>
<li>令牌有权限范围</li>
</ul>
</li>
</ul>
<h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ul>
<li><a href="https://tools.ietf.org/html/rfc6749">标准文件</a></li>
<li>OAuth2.0有四种获得令牌的流程<ul>
<li>授权码<ul>
<li>最常用，安全性最高<br><img src="/images/oauth-code.png" alt="授权码"></li>
</ul>
</li>
<li>隐藏式<ul>
<li>适用于纯前端应用</li>
<li>由于存在无后端的纯前端应用，故有隐藏式的一种方式，其实就是授权码的一种简化版，去掉code的过程，直接返回令牌</li>
<li>注意： 令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</li>
</ul>
</li>
<li>密码式<ul>
<li>适用于高度信任某个应用</li>
<li>A网站要求用户提供B网站的账号密码，然后直接获取令牌</li>
<li>这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li>
</ul>
</li>
<li>凭证式<ul>
<li>适用于没有前端的命令行应用，即在命令行下请求令牌。</li>
<li>发送凭证，直接获取令牌</li>
</ul>
</li>
</ul>
</li>
<li>令牌的使用<ul>
<li>请求头添加 Authorization，每次请求都需要</li>
</ul>
</li>
<li>更新令牌<ul>
<li>B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌</li>
<li>B 网站验证通过以后，就会颁发新的令牌。</li>
</ul>
</li>
</ul>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 网站让用户跳转到 GitHub。</span><br><span class="line">GitHub 要求用户登录，然后询问&quot;A 网站要求获得 xx 权限，你是否同意？&quot;</span><br><span class="line">用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。</span><br><span class="line">A 网站使用授权码，向 GitHub 请求令牌。</span><br><span class="line">GitHub 返回令牌.</span><br><span class="line">A 网站使用令牌，向 GitHub 请求用户数据。</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title>理解OIDC</title>
    <url>/2022/07/19/%E7%90%86%E8%A7%A3OIDC/</url>
    <content><![CDATA[<h3 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h3><ul>
<li>OIDC 是实现单点登录的方式之一</li>
<li>主要解决的问题：在使用 OAuth2.0 中，发现，虽然有了令牌可以进行操作，但是缺乏对身份的识别，无法有效的辨认身份，所以在 OAuth2.0 的基础上，拓展的了返回<code>token</code>，增加了<code>ID Token</code></li>
</ul>
<h3 id="ID-Token"><a href="#ID-Token" class="headerlink" title="ID Token"></a>ID Token</h3><ul>
<li>OIDC 中定义的<code>ID Token</code>使用的<a href="https://datatracker.ietf.org/doc/html/rfc7515">JWS</a>，样子大概如下</li>
</ul>
<blockquote>
<p>eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ.ewogImlz<br>cyI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4<br>Mjg5NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAi<br>bi0wUzZfV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEz<br>MTEyODA5NzAsCiAibmFtZSI6ICJKYW5lIERvZSIsCiAiZ2l2ZW5fbmFtZSI6<br>ICJKYW5lIiwKICJmYW1pbHlfbmFtZSI6ICJEb2UiLAogImdlbmRlciI6ICJm<br>ZW1hbGUiLAogImJpcnRoZGF0ZSI6ICIwMDAwLTEwLTMxIiwKICJlbWFpbCI6<br>ICJqYW5lZG9lQGV4YW1wbGUuY29tIiwKICJwaWN0dXJlIjogImh0dHA6Ly9l<br>eGFtcGxlLmNvbS9qYW5lZG9lL21lLmpwZyIKfQ.rHQjEmBqn9Jre0OLykYNn<br>spA10Qql2rvx4FsD00jwlB0Sym4NzpgvPKsDjn_wMkHxcp6CilPcoKrWHcip<br>R2iAjzLvDNAReF97zoJqq880ZD1bwY82JDauCXELVR9O6_B0w3K-E7yM2mac<br>AAgNCUwtik6SjoSUZRcf-O5lygIyLENx882p6MtmwaL1hd6qn5RZOQ0TLrOY<br>u0532g9Exxcm-ChymrB4xLykpDj3lUivJt63eEGGN6DH5K6o33TcxkIjNrCD<br>4XB1CKKumZvCedgHHF3IAK4dVEDSUoGlH9z4pP_eWYNXvqQOjGs-rDaQzUHl<br>6cQQWNiDpWOl_lxXjQEvQ</p>
</blockquote>
<p>根据规范中的定义，可以按照<code>.</code>分成三部分，规范如下</p>
<blockquote>
<p>BASE64URL(UTF8(JWS Protected Header)) || ‘.’ ||<br>BASE64URL(JWS Payload) || ‘.’ ||<br>BASE64URL(JWS Signature)</p>
</blockquote>
<p>分开后，用 base64url decode 可以得到以下内容</p>
<blockquote>
<p>Header:{“kid”:”1e9gdk7”,”alg”:”RS256”}<br>Payload:{<br> “iss”: “<a href="http://server.example.com&quot;/">http://server.example.com&quot;</a>,<br> “sub”: “248289761001”,<br> “aud”: “s6BhdRkqt3”,<br> “nonce”: “n-0S6_WzA2Mj”,<br> “exp”: 1311281970,<br> “iat”: 1311280970,<br> “name”: “Jane Doe”,<br> “given_name”: “Jane”,<br> “family_name”: “Doe”,<br> “gender”: “female”,<br> “birthdate”: “0000-10-31”,<br> “email”: “<a href="mailto:&#x6a;&#x61;&#x6e;&#x65;&#x64;&#111;&#x65;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x61;&#x6e;&#x65;&#x64;&#111;&#x65;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;</a>“,<br> “picture”: “<a href="http://example.com/janedoe/me.jpg&quot;">http://example.com/janedoe/me.jpg&quot;</a><br>}</p>
</blockquote>
<p>Signature 是一个二进制的数据，用来验证 Header 和 Payload 内容的完整性<br>通过这样的结构，就可以获取身份的信息，并且通过验证可以安全的去使用</p>
]]></content>
  </entry>
  <entry>
    <title>理解CAS</title>
    <url>/2022/07/20/%E7%90%86%E8%A7%A3CAS/</url>
    <content><![CDATA[<ul>
<li>集中式认证服务（英语：Central Authentication Service，缩写CAS）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需向认证服务器提供一次凭证（如用户名和密码）。在使用服务前，如果是没有登录的使用者，会先被跳转到认证服务的地方进行登录，登录成功后就会重定向到原本使用服务的页面</li>
<li>Authentication 代表的是否是具体人 Authorization 代表的是否是有权限获取资源（大概的对比😂）</li>
<li>角色<ul>
<li>使用者： 用户</li>
<li>应用服务A：使用者必须要登录才能使用的 A 服务(AP1)</li>
<li>应用服务B：使用者必须要登录才能使用的 B 服务(AP2)</li>
<li>CAS Server：使用者被重定向到的输入密码的地方</li>
</ul>
</li>
<li>流程<ul>
<li>第一次登录 使用 A<br><img src="/images/case-01.png" alt="首次登录"></li>
<li>第二次登录 使用 B<br><img src="/images/case-02.png" alt="再次登录"></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>理解SAML</title>
    <url>/2022/07/20/%E7%90%86%E8%A7%A3SAML/</url>
    <content><![CDATA[<ul>
<li>安全声明标记语言（SAML）是一种开放标准，允许身份提供商（IDP）将授权凭证传递给服务提供商（SP），它是一个基于XML的标准协议。SAML使用可扩展标记语言（XML）进行身份提供商和服务提供商之间的标准化通信。 SAML是用户身份验证和使用服务授权之间的链接。</li>
<li>角色<ul>
<li>当事人&#x2F;主体：用户</li>
<li>身份提供者（IDP）：身份提供者 (IdP) 是一种云软件服务，通常通过登录过程来存储和确认用户身份</li>
<li>服务提供商（SP）：这是用户希望使用的云托管应用程序或服务</li>
</ul>
</li>
<li>流程<ul>
<li>当事人向服务提供商发出请求。服务提供商接着向身份提供者请求身份验证。身份提供者将 SAML 断言发送给服务提供商，然后服务提供商可以将响应发送给当事人。如果当事人（用户）尚未登录，身份提供者可以提醒他们登录，然后再发送 SAML 断言。</li>
<li>在整个流程中，IDP是负责颁发用户身份，SP负责信任IDP颁发的用户身份, SP和IDP之间的信任关系是需要提前建立的，即SP和IDP需要提前把双方的信息预先配置到对方，通过证书信任的方式来建立互信</li>
</ul>
</li>
<li>SAML 断言：是告知服务提供商用户已经登录的消息。SAML 断言包含服务提供商确认用户身份需要的所有信息，包括断言的来源、签发时间，以及有效断言应满足的条件。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Omit.js源码</title>
    <url>/2022/08/02/Omit-js%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7127275216807395341">掘金</a></li>
</ul>
<h3 id="Omit-js-源码分析"><a href="#Omit-js-源码分析" class="headerlink" title="Omit.js 源码分析"></a>Omit.js 源码分析</h3><ul>
<li><a href="https://github.com/benjycui/omit.js">仓库地址</a></li>
<li>源码路径 omit.js&#x2F;src&#x2F;index.js</li>
<li>功能介绍</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> omit = <span class="built_in">require</span>(<span class="string">&#x27;omit.js&#x27;</span>);</span><br><span class="line"><span class="title function_">omit</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Benjy&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;, [ <span class="string">&#x27;name&#x27;</span> ]); <span class="comment">// =&gt; &#123; age: 18 &#125;</span></span><br></pre></td></tr></table></figure>
<p>   如上所示，通过第二个参数剔除，不需要的 key</p>
<ul>
<li>源码分析</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">omit</span>(<span class="params">obj, fields</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> shallowCopy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = fields[i];</span><br><span class="line">    <span class="keyword">delete</span> shallowCopy[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> shallowCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> omit;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 Object.assign 创建出一个浅拷贝的对象</li>
<li>循环 fields，删除拷贝对象中对应的 key</li>
<li>返回拷贝值</li>
</ol>
<ul>
<li>对比 <a href="https://github.com/lodash/lodash/blob/es/omit.js">lodash&#x2F;omit</a></li>
</ul>
<ol>
<li>lodash 考虑了 深拷贝的情况（fields 中是否有 数组的子项）</li>
<li>lodash 考虑了边界情况，如 obj 是否为 null；fields 是否为一个类数组；fields 中是否有特殊的 key（__proto__）</li>
<li>lodash 没有使用 es6 的方法，兼容性会更好些</li>
</ol>
<h3 id="npm-包所包含的内容"><a href="#npm-包所包含的内容" class="headerlink" title="npm 包所包含的内容"></a>npm 包所包含的内容</h3><ul>
<li>&#x2F;tests jest测试</li>
<li><a href="https://github.com/umijs/father">father</a><blockquote>
<p> Library toolkit based on rollup, docz, storybook, jest, prettier and eslint.<br> 包括了库的打包、输出文档、测试及格式化</p>
</blockquote>
</li>
<li>LICENSE 证书</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Arrify源码</title>
    <url>/2022/08/06/Arrify%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7128772727913545759">掘金</a></li>
</ul>
<h3 id="Arrify源码"><a href="#Arrify源码" class="headerlink" title="Arrify源码"></a>Arrify源码</h3><ul>
<li>arrify 指的是 一个值转换为数组</li>
<li><a href="https://github.com/sindresorhus/arrify">仓库地址</a></li>
<li>功能介绍</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">arrify</span>(<span class="params">value</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (value === <span class="literal">null</span> || value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> [];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> [value];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> value[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> [...value];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码分析处理了以下逻辑</p>
<ol>
<li><code>null</code>和<code>undefined</code>处理为<code>[]</code></li>
<li>对于数组类型直接返回</li>
<li>对于<code>string</code>返回<code>[string]</code></li>
<li>对于存在迭代器的返回通过<code>...</code>运算符执行迭代器的返回值的集合转换为数组</li>
<li>其他情况返回为<code>[value]</code><br>   特别的是字符串类型其实是有迭代器的，也就是满足 4 的情况，但是比较符合大家逻辑预期的其实是连续的字符串的数组返回，如果使用 4 的情况会返回拆解字符串组成的数组</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>test.js 为 js 测试</li>
<li>index.d.ts 为 ts 类型定义</li>
<li>index.test-d.ts 为 ts 类型定义的测试</li>
<li>package 中的一些依赖<ul>
<li>ava 测试 js 代码<blockquote>
<p>AVA 是 Node.js 的测试运行程序，具有简洁的 API、详细的错误输出、新的语言特性和进程隔离，让您可以放心地进行开发</p>
</blockquote>
</li>
<li>tsd <blockquote>
<p>检查 TypeScript 类型定义</p>
</blockquote>
</li>
<li>xo<blockquote>
<p>JavaScript&#x2F;TypeScript linter（ESLint 包装器）具有很好的默认值</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2-shared源码</title>
    <url>/2022/08/08/vue2-shared%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7129517974452437029">掘金</a></li>
</ul>
<h3 id="vue2-shared-源码分析"><a href="#vue2-shared-源码分析" class="headerlink" title="vue2-shared 源码分析"></a>vue2-shared 源码分析</h3><ul>
<li><p><a href="https://github.com/vuejs/vue/blob/dev/dist/vue.js#L14-L379">打包后代码地址</a></p>
</li>
<li><p><a href="https://github.com/vuejs/vue/tree/dev/src/shared">源码地址 src&#x2F;shared&#x2F;</a></p>
</li>
<li><p>工具函数(util.ts)</p>
<ul>
<li>emptyObject <code>Object.freeze(&#123;&#125;)</code> 冻结对象</li>
<li>isArray Array.isArray</li>
<li>isUndef 是否未定义 判断是否为<code>null</code> | <code>undefined</code></li>
<li>isDef 是否定义 判断不是<code>null</code> &amp;&amp; <code>undefined</code></li>
<li>isTrue 是否为<code>true</code></li>
<li>isFalse 是否为<code>false</code></li>
<li>isPrimitive 是否为原始类型 判断是否为<code>string``number``symbol``boolean</code></li>
<li>isFunction 是否为函数</li>
<li>isObject 是否为对象</li>
<li>toRawType 返回真实类型 调用<code>Object.prototype.toString</code> 获取后面的那个类型</li>
<li>isPlainObject 是否为纯对象</li>
<li>isRegExp 是否是正则</li>
<li>isValidArrayIndex 判断是否可以为数组索引，其中调用<code>isFinite</code>判断是否为有限数</li>
<li>isPromise 是否是promise</li>
<li>toString 转换为字符串</li>
<li>toNumber 转换成<code>number</code></li>
<li>makeMap 生成一个<code>map</code>，返回一个可供查询的函数，第一个参数为字典，第二个为是否大小写敏感</li>
<li>isBuiltInTag 由<code>makeMap</code>生成的查询函数 判断是否为<code>slot</code>或<code>component</code></li>
<li>isReservedAttribute  <code>makeMap(&#39;key,ref,slot,slot-scope,is&#39;)</code> 功能同上，检查map不同</li>
<li>remove 删除数组一个item</li>
<li>hasOwn 是否有这个<code>property</code></li>
<li>cached 利用闭包进行缓存</li>
<li>camelize 连词符转小驼峰</li>
<li>capitalize 首字母大写</li>
<li>hyphenate 小驼峰转连词符</li>
<li>bind<ul>
<li>polyfillBind bind的降级版本 针对不同参数，进行使用call和apply的取舍</li>
<li>nativeBind 原生bind</li>
<li>分别实现两种bind 通过判断返回可用的bind</li>
</ul>
</li>
<li>toArray 类数组转数组，支持以第二个参数为startIndex，返回一个新的数组</li>
<li>extend 把from的添加到to中</li>
<li>toObject 把数组每一项转换为对象，然后对这些对象做extend</li>
<li>noop 空函数</li>
<li>no 返回false的函数</li>
<li>identity 返回参数本身</li>
<li>genStaticKeys 生成静态key 把 modules 中的每个staticKeys合并并生成字符串返回</li>
<li>looseEqual 比较两个值是否相同，是宽松相等，只比值，不比引用</li>
<li>looseIndexOf 用上面方法比较数组中是否存在某个值，并返回index</li>
<li>once 执行一次的函数</li>
<li>hasChanged  与<code>Object.is</code>功能相同，不过是判断是否改变，返回相反，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill">mdn</a></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hasChanged</span>(<span class="params">x: <span class="built_in">unknown</span>, y: <span class="built_in">unknown</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x === <span class="number">0</span> &amp;&amp; <span class="number">1</span> / x !== <span class="number">1</span> / (y <span class="keyword">as</span> <span class="built_in">number</span>)  <span class="comment">// 考虑-0、+0的情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x === x || y === y <span class="comment">// 考虑NaN的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典(constants.ts)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SSR_ATTR</span> = <span class="string">&#x27;data-server-rendered&#x27;</span></span><br><span class="line"><span class="comment">//ssr </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASSET_TYPES</span> = [<span class="string">&#x27;component&#x27;</span>, <span class="string">&#x27;directive&#x27;</span>, <span class="string">&#x27;filter&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LIFECYCLE_HOOKS</span> = [</span><br><span class="line">  <span class="string">&#x27;beforeCreate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;created&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeMount&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mounted&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeUpdate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;updated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeDestroy&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;destroyed&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;activated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deactivated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;errorCaptured&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;serverPrefetch&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;renderTracked&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;renderTriggered&#x27;</span></span><br><span class="line">] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 生命周期</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>函数名语义话，便于阅读与理解代码</li>
<li>函数功能固定唯一，粒子性高</li>
<li>bind 的降级与 isChange 考虑了特殊情况</li>
<li>最后的vue2版本已经用ts重写了类型，类型检查是很重要的</li>
<li>阅读评论，看到一点 ES3中<code>undefined</code>是可以被赋值的。ES5之后全局的<code>undefined</code>就不能赋值了,但是局部的还是可以被赋值修改</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>yocto-queue源码</title>
    <url>/2022/08/09/yocto-queue%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7129753511926956046">掘金</a></li>
</ul>
<h3 id="yocto-queue-源码分析"><a href="#yocto-queue-源码分析" class="headerlink" title="yocto-queue 源码分析"></a>yocto-queue 源码分析</h3><ul>
<li><p><a href="https://github.com/sindresorhus/yocto-queue">仓库地址</a></p>
</li>
<li><p>功能介绍</p>
<blockquote>
<p>这是一个队列的实现，并通过迭代器实现了用<code>...</code>运算符转换为数组</p>
</blockquote>
</li>
<li><p>源码分析</p>
<ul>
<li>Node 类：用于创建队列中的一个节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value;</span><br><span class="line">    next;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li>Queue 类：队列核心</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    #head; <span class="comment">// 保存队列头</span></span><br><span class="line">    #tail; <span class="comment">// 保存队列尾</span></span><br><span class="line">    #size; <span class="comment">// 保存队列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">clear</span>(); <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123; <span class="comment">// 入列</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(value); <span class="comment">// 创建节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.#head) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#tail.<span class="property">next</span> = node;</span><br><span class="line">            <span class="variable language_">this</span>.#tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#head = node;</span><br><span class="line">            <span class="variable language_">this</span>.#tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.#size++; <span class="comment">//更新长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123; <span class="comment">// 出列</span></span><br><span class="line">        <span class="keyword">const</span> current = <span class="variable language_">this</span>.#head; <span class="comment">// 获取对头</span></span><br><span class="line">        <span class="keyword">if</span> (!current) &#123; <span class="comment">// 是否存在</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.#head = <span class="variable language_">this</span>.#head.<span class="property">next</span>;  <span class="comment">// 移动头</span></span><br><span class="line">        <span class="variable language_">this</span>.#size--; <span class="comment">// 更新长度</span></span><br><span class="line">        <span class="keyword">return</span> current.<span class="property">value</span>; <span class="comment">// 返回对头值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123; <span class="comment">// 私有变量重新初始化</span></span><br><span class="line">        <span class="variable language_">this</span>.#head = <span class="literal">undefined</span>; </span><br><span class="line">        <span class="variable language_">this</span>.#tail = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">this</span>.#size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="comment">// 返回内部长度变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="comment">// 迭代器，用于转换为数组</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="variable language_">this</span>.#head; <span class="comment">// 获取对头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current) &#123; <span class="comment">// 循环队列</span></span><br><span class="line">            <span class="keyword">yield</span> current.<span class="property">value</span>; <span class="comment">// 使用yield输出节点值</span></span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个简单的单向链表队列实现：队列可以理解为生活中的排队，比如地铁站的排队，先到的先进</li>
<li>使用了迭代器便于操作者的转换使用</li>
<li>对比数组：<ul>
<li>数组存储是连续的，队列链表是通过指针的</li>
<li>数组的删除添加更灵活(O(n))，队列链表只能在后面插入，前面移出(O(1))</li>
<li>数组的查找简单(O(1))，队列链表需要循环(O(n))</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>koa-compose源码</title>
    <url>/2022/08/30/koa-compose%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7137632272970153991/">掘金</a></li>
</ul>
<h3 id="koa-compose-源码"><a href="#koa-compose-源码" class="headerlink" title="koa-compose 源码"></a>koa-compose 源码</h3><ul>
<li><p><a href="https://github.com/lxchuan12/koa-compose-analysis">仓库地址</a></p>
</li>
<li><p>功能介绍：洋葱模型式调用中间件函数 <a href="https://github.com/koajs/koa/blob/master/docs/guide.md#writing-middleware">官网介绍</a><br><img src="/images/koa-compose.awebp" alt="功能介绍图"></p>
</li>
<li><p>源码分析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (middleware) &#123;</span><br><span class="line">  <span class="comment">// 参数检测</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware stack must be an array!&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware must be composed of functions!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123; <span class="comment">// context 上下文，用于共享状态类似store， next 自定义到中心后的处理函数</span></span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span> <span class="comment">// 初始值  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>) <span class="comment">// 初始值从 0 开始</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span> (i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>)) <span class="comment">// 防止重复调用</span></span><br><span class="line">      index = i <span class="comment">// index 获取当前 middleware 调用指针</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i] <span class="comment">// 获取获取当前 middleware 函数</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next <span class="comment">// 如果到了最后一个，赋值为 compose(middleware)(context, next) 中 next 的值，也就是说可以定义结束时的自定义next</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() <span class="comment">// 如果 fn 不存在，走到这里证明没有传入next 就可以结束了</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>))) <span class="comment">// promise调用， 函数传入 context 和 第二个 dispath，在调用 next 的时候就是第二个的调用，依次类推</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err) <span class="comment">// 错误结束</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>学习了<code>koa-compose</code>的实现，通过<code>Promise.resolve</code>第二个参数进行递归调用<code>dispatch</code>执行后面的中间件函数</li>
<li>学习使用<code>jest</code>分步调试代码</li>
<li>设计模式-责任链模式： 是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止；这里的中间件也就是多个的处理器，只需要去关心自己要处理的内容，结合洋葱模型，<code>koa</code>使责任链中先经过请求，然后响应，通过中间件函数中的 <code>next</code>去做，响应与请求的分割，通过 <code>context</code> 共享数据</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>classNames源码</title>
    <url>/2022/09/03/classNames%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7139080024522670094">掘金</a></li>
</ul>
<h3 id="classNames-源码分析"><a href="#classNames-源码分析" class="headerlink" title="classNames 源码分析"></a>classNames 源码分析</h3><ul>
<li><a href="https://github.com/JedWatson/classnames">仓库地址</a></li>
<li>功能介绍<blockquote>
<p>这是一个常用的合并 css 中 class 名的工具函数库</p>
</blockquote>
</li>
<li>提前准备 <ul>
<li>git clone <a href="https://github.com/JedWatson/classnames">https://github.com/JedWatson/classnames</a></li>
<li>或者查看 <a href="https://github.com/JedWatson/classnames/blob/master/index.js">https://github.com/JedWatson/classnames/blob/master/index.js</a></li>
<li>测试用例中的<code>assert.equal</code>为判断是否相等的函数，传入的删除相等的时候就会通过测试用例</li>
</ul>
</li>
<li>手动实现：通过阅读 tests 文件夹中的测试用例我们可以逐条实现<ol>
<li>传入参数为单一对象 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(</span><br><span class="line">    <span class="title function_">classNames</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">f</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="string">&quot;a f&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
 观察测试可以看出，传入为一个对象，根据 key 对应的 value 选择是否保留 key 到返回值中，由此可以写出以下代码 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; obj[key]) &#123;</span><br><span class="line">            classes.<span class="title function_">push</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当传入参数为多个基础类型 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="string">&quot;b&quot;</span>), <span class="string">&quot;a 1 b&quot;</span>);</span><br></pre></td></tr></table></figure>
 观察测试可以看出，传入多个参数时，根据是否为真值，然后判断为字符串和数字，选择是否保留该参数，由此可以写出以下代码 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当传入参数为 1 和 2 两种情况的合集 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(&#123; <span class="attr">a</span>: <span class="literal">true</span> &#125;, <span class="string">&quot;b&quot;</span>, <span class="number">0</span>), <span class="string">&quot;a b&quot;</span>);</span><br></pre></td></tr></table></figure>
 根据测试用例，和前两步写的代码，对代码进行合并，可以写出以下代码 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; element[key]) &#123;</span><br><span class="line">                        classes.<span class="title function_">push</span>(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需要去掉两遍的空格 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, &#123;&#125;, <span class="string">&quot;&quot;</span>), <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
 因为我们之前的代码包括了处理假值的情况，所以无需修改代码 </li>
<li>在传入空对象时，返回空字符串     <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(&#123;&#125;), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
 运行下已经写的代码，满足条件进行下一条 </li>
<li>传入参数为一个字符串数组的时候，需要返回数组的 value 拼接 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]), <span class="string">&quot;a b&quot;</span>);</span><br></pre></td></tr></table></figure>
 根据这种情况修改代码，可以写出以下代码 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.<span class="property">length</span>) &#123;</span><br><span class="line">                    classes = classes.<span class="title function_">concat</span>(element);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; element[key]) &#123;</span><br><span class="line">                        classes.<span class="title function_">push</span>(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>传入参数为字符串数组和字符串  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], <span class="string">&quot;c&quot;</span>), <span class="string">&quot;a b c&quot;</span>);</span><br><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="string">&quot;c&quot;</span>, [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]), <span class="string">&quot;c a b&quot;</span>);</span><br></pre></td></tr></table></figure>
  运行下已经写的代码，满足条件进行下一条</li>
<li>传入参数为多个字符串数组 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]), <span class="string">&quot;a b c d&quot;</span>);</span><br></pre></td></tr></table></figure>
 运行下已经写的代码，满足条件进行下一条 </li>
<li>传入一个数组，并且每个值为基础类型时 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="string">&quot;b&quot;</span>]), <span class="string">&quot;a b&quot;</span>);</span><br></pre></td></tr></table></figure>
 运行下已经写的代码，发现出现了问题，需要对数组的每一项进行校验，这时我们会有两种选择，因为我们处理过这种逻辑，所以可以抽离这个处理逻辑，这是一种处理方式，还有一种就是可以把数组作为参数，调用我们的 classNames，进行递归调用，这里我们选择第二种处理方式，防止在很多嵌套的情况，这里类似树结构的两种遍历方式，可以写出以下代码 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> inner = <span class="title function_">classNames</span>(...element);</span><br><span class="line">                    classes.<span class="title function_">push</span>(inner);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; element[key]) &#123;</span><br><span class="line">                        classes.<span class="title function_">push</span>(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>传入参数数组包含数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]]), <span class="string">&quot;a b c&quot;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件进行下一条</li>
<li>传入数组中包含对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&quot;a&quot;</span>, &#123; <span class="attr">b</span>: <span class="literal">true</span>, <span class="attr">c</span>: <span class="literal">false</span> &#125;]), <span class="string">&quot;a b&quot;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件进行下一条 </li>
<li>传入参数为数组并且嵌套<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>([<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">d</span>: <span class="literal">true</span>&#125;]]]), <span class="string">&#x27;a b c d&#x27;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件进行下一条 </li>
<li>传入参数中有空数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="string">&#x27;a&#x27;</span>, []), <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件进行下一条 </li>
<li>传入参数中有嵌套空数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="string">&#x27;a&#x27;</span>, [[]]), <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，发现出现了问题，函数运行结果为<code>&#39;a &#39;</code>，多了个空格，查看代码，发现存在递归数组为空的情况，不应该添加，修改代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> inner = <span class="title function_">classNames</span>(...element);</span><br><span class="line">                    inner &amp;&amp; classes.<span class="title function_">push</span>(inner);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; element[key]) &#123;</span><br><span class="line">                        classes.<span class="title function_">push</span>(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试传入参数对象值为所有为<code>falsy</code>和<code>truthy</code>的情况<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(&#123;</span><br><span class="line">	<span class="comment">// falsy:</span></span><br><span class="line">	<span class="attr">null</span>: <span class="literal">null</span>,</span><br><span class="line">	<span class="attr">emptyString</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	<span class="attr">noNumber</span>: <span class="title class_">NaN</span>,</span><br><span class="line">	<span class="attr">zero</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">negativeZero</span>: -<span class="number">0</span>,</span><br><span class="line">	<span class="attr">false</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">undefined</span>: <span class="literal">undefined</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// truthy (literally anything else):</span></span><br><span class="line">	<span class="attr">nonEmptyString</span>: <span class="string">&quot;foobar&quot;</span>,</span><br><span class="line">	<span class="attr">whitespace</span>: <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">	<span class="attr">function</span>: <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>,</span><br><span class="line">	<span class="attr">emptyObject</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">nonEmptyObject</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">	<span class="attr">emptyList</span>: [],</span><br><span class="line">	<span class="attr">nonEmptyList</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	<span class="attr">greaterZero</span>: <span class="number">1</span></span><br><span class="line">&#125;), <span class="string">&#x27;nonEmptyString whitespace function emptyObject nonEmptyObject emptyList nonEmptyList greaterZero&#x27;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件进行下一条 </li>
<li>当传入参数为对象并有<code>toString</code>方法的时候，应返回该方法的调用值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(&#123;</span><br><span class="line">	<span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;classFromMethod&#x27;</span>; &#125;</span><br><span class="line">&#125;), <span class="string">&#x27;classFromMethod&#x27;</span>);</span><br></pre></td></tr></table></figure>
根据测试修改代码为以下代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classNames</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = [];</span><br><span class="line">    arg.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> element === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            classes.<span class="title function_">push</span>(element);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(element)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> inner = <span class="title function_">classNames</span>(...element);</span><br><span class="line">                inner &amp;&amp; classes.<span class="title function_">push</span>(inner);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(element.<span class="property">toString</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>) &#123; <span class="comment">// 是否为原装</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> element) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (element.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; element[key]) &#123;</span><br><span class="line">                        classes.<span class="title function_">push</span>(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                classes.<span class="title function_">push</span>(element.<span class="title function_">toString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> classes.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当传入参数为对象并继承<code>toString</code>方法的时候，应返回该方法的调用值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">var</span> <span class="title class_">Class1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Class2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Class1</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;classFromMethod&#x27;</span>; &#125;</span><br><span class="line"><span class="title class_">Class2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Class1</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">assert.<span class="title function_">equal</span>(<span class="title function_">classNames</span>(<span class="keyword">new</span> <span class="title class_">Class2</span>()), <span class="string">&#x27;classFromMethod&#x27;</span>);</span><br></pre></td></tr></table></figure>
运行下已经写的代码，满足条件</li>
</ol>
<ul>
<li>根据这些测试用例，其实我们已经完成了<code>className</code>的所有功能，这其实就是测试驱动开发</li>
</ul>
</li>
<li>手动实现与源码对比<ul>
<li>源码使用<code>apply</code>，强绑定了this，兼容性更好</li>
<li>源码参数为空的时候提前返回，可以减少阅读者的理解成本</li>
<li>源码对于多次调用的<code>typeof</code>判断进行抽离为变量，减少重复判断 </li>
<li>源码提取<code>hasOwnProperty</code>方法，使用<code>call</code>，强绑定了this</li>
<li>源码实现了一个umd的形式，去导出方法</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>学习了源码的实现，使用了umd的导出方式</li>
<li>通过测试驱动的形式自己实现了<code>classNames</code>，测试可以极大程度上增加代码的健壮性</li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js-cookie源码</title>
    <url>/2022/09/08/js-cookie%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><a href="https://juejin.cn/post/7141305632220512263">掘金</a></li>
</ul>
<h3 id="js-cookie-源码"><a href="#js-cookie-源码" class="headerlink" title="js-cookie 源码"></a>js-cookie 源码</h3><ul>
<li><a href="https://github.com/js-cookie/js-cookie">仓库地址</a></li>
<li>功能介绍：在浏览器上操作cookie的封装<br><img src="https://cloud.githubusercontent.com/assets/835857/14581711/ba623018-0436-11e6-8fce-d2ccd4d379c9.gif" alt="功能介绍"></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie">cookie知识</a></li>
<li>手动实现<br>根据<code>cookie</code>的知识，我们可以把操作分为增删改查这几种操作，其中增删改都可以通过一个<code>set</code>去实现，所以我们主要需要完成<code>get</code>操作和<code>set</code>操作，另外我们知道一个<code>cookie</code>包括<code>name</code>、<code>value</code>、<code>path</code>等属性，其中<code>key</code>和<code>value</code>为必须的，其他不是必须的，所以我们分隔下，其他属性当作<code>attribute</code><ol>
<li>get(name?:string)<br>  功能：当没有传入<code>name</code>的时候全部返回，如果传入，判断是否在<code>cookie</code>中，如果有就返回  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cookies = <span class="variable language_">document</span>?.<span class="property">cookie</span>?.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>) || []</span><br><span class="line">    <span class="keyword">let</span> cookieStore = &#123;&#125;</span><br><span class="line">    cookies.<span class="title function_">some</span>(<span class="function"><span class="params">cookie</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [found, ...valuesArr] = cookie.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> value = valuesArr.<span class="title function_">join</span>(<span class="string">&quot;=&quot;</span>) <span class="comment">// 防止value存在=的情况</span></span><br><span class="line">        cookieStore[found] = value</span><br><span class="line">        <span class="keyword">return</span> found === name</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> name ? cookieStore[name] : cookieStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>set(name:string, value:string, attributes: Record&lt;string,any&gt;)<br>  功能：根据传入设置<code>cookie</code>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">name, value, attributes</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> attributesOfString = <span class="title class_">Object</span>.<span class="title function_">entries</span>(attributes).<span class="title function_">reduce</span>(<span class="function">(<span class="params">preString, nextPreAttribute</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [name, value] = nextPreAttribute</span><br><span class="line">        <span class="keyword">if</span>(!value) <span class="keyword">return</span> preString</span><br><span class="line">        preString += <span class="string">`; <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">        <span class="keyword">if</span>(value === <span class="literal">true</span>) <span class="keyword">return</span> preString</span><br><span class="line">        preString += <span class="string">`=<span class="subst">$&#123;value.split(<span class="string">&#x27;;&#x27;</span>)[<span class="number">0</span>]&#125;</span>`</span> <span class="comment">// 防止value有;的情况</span></span><br><span class="line">    &#125;,<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">`<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>;<span class="subst">$&#123;attributesOfString&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他操作：<br>  remove:  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>( name, <span class="string">&#x27;&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">expires</span>: -<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>基本功能到此就结束了</li>
</ol>
</li>
<li>对比源码<ul>
<li>在<code>attribute</code>中添加默认对象，并提供<code>withAttributes</code>修改默认对象</li>
<li>提供<code>withConverter</code>，提供自定义转换器，用于转换生成的cookie及查到的cookie</li>
<li>代码上主要对比<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> converter = &#123; <span class="comment">// 默认的转换器</span></span><br><span class="line">      <span class="attr">read</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value[<span class="number">0</span>] === <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">          value = value.<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> value.<span class="title function_">replace</span>(<span class="regexp">/(%[\dA-F]&#123;2&#125;)+/gi</span>, <span class="built_in">decodeURIComponent</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">write</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(value).<span class="title function_">replace</span>(</span><br><span class="line">          <span class="regexp">/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g</span>,</span><br><span class="line">          <span class="built_in">decodeURIComponent</span></span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      attributes = <span class="title function_">assign</span>(&#123;&#125;, defaultAttributes, attributes) <span class="comment">//合并默认</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> attributes.<span class="property">expires</span> === <span class="string">&#x27;number&#x27;</span>) &#123; <span class="comment">// 把传入的时间数字格式化为时间对象</span></span><br><span class="line">          attributes.<span class="property">expires</span> = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() + attributes.<span class="property">expires</span> * <span class="number">864e5</span>) <span class="comment">// 864e5 为一天</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (attributes.<span class="property">expires</span>) &#123;</span><br><span class="line">          attributes.<span class="property">expires</span> = attributes.<span class="property">expires</span>.<span class="title function_">toUTCString</span>() <span class="comment">// 统一格式化为标准时间字符串</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      name = <span class="built_in">encodeURIComponent</span>(name) <span class="comment">// 对 name 编码，防止不能处理的情况</span></span><br><span class="line">          .<span class="title function_">replace</span>(<span class="regexp">/%(2[346B]|5E|60|7C)/g</span>, <span class="built_in">decodeURIComponent</span>)</span><br><span class="line">          .<span class="title function_">replace</span>(<span class="regexp">/[()]/g</span>, <span class="built_in">escape</span>)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="variable language_">document</span>.<span class="property">cookie</span> =</span><br><span class="line">name + <span class="string">&#x27;=&#x27;</span> + converter.<span class="title function_">write</span>(value, name) + stringifiedAttributes) <span class="comment">// converter 为 传入的转换器，返回字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">var</span> found = <span class="built_in">decodeURIComponent</span>(parts[<span class="number">0</span>]) <span class="comment">// 解码 name</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
整体上代码对比<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> assign <span class="keyword">from</span> <span class="string">&#x27;./assign.mjs&#x27;</span> <span class="comment">// 合并函数</span></span><br><span class="line"><span class="keyword">import</span> defaultConverter <span class="keyword">from</span> <span class="string">&#x27;./converter.mjs&#x27;</span> <span class="comment">// 获取默认转换器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">converter, defaultAttributes</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">set</span> (name, value, attributes) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">get</span> (name) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">set</span>: set,</span><br><span class="line">        <span class="attr">get</span>: get,</span><br><span class="line">        <span class="attr">remove</span>: <span class="keyword">function</span> (<span class="params">name, attributes</span>) &#123;</span><br><span class="line">            <span class="title function_">set</span>(name, <span class="string">&#x27;&#x27;</span>, <span class="title function_">assign</span>(&#123;&#125;, attributes, &#123;<span class="attr">expires</span>: -<span class="number">1</span>&#125;))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">withAttributes</span>: <span class="keyword">function</span>(<span class="params">attributes</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">init</span>(<span class="variable language_">this</span>.<span class="property">converter</span>, <span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">attributes</span>, attributes))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">withConverter</span>: <span class="keyword">function</span> (<span class="params">converter</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">init</span>(<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">converter</span>, converter), <span class="variable language_">this</span>.<span class="property">attributes</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">attributes</span>: &#123; <span class="attr">value</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(defaultAttributes) &#125;,</span><br><span class="line">        <span class="attr">converter</span>: &#123; <span class="attr">value</span>: <span class="title class_">Object</span>.<span class="title function_">freeze</span>(converter) &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">init</span>(defaultConverter, &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
每次修改配置，都会返回一个新的操作<code>cookie</code>的对象</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>js-cookie中返回的对象中，包括了<ul>
<li><code>get</code> 获取cookie</li>
<li><code>set</code> 设置cookie </li>
<li><code>remove</code> 删除cookie</li>
<li><code>withAttributes</code> 更新默认配置</li>
<li><code>withConverter</code> 更新默认转换器</li>
</ul>
</li>
<li>通过返回的方法去操作内部的方法，利用闭包对操作进行了隔离，防止使用者对内部函数覆盖，也防止了内部函数污染全局</li>
</ul>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><ul>
<li><a href="https://github.com/frehner/modern-guide-to-packaging-js-library/blob/main/README-zh_CN.md">打包 JavaScript 库的现代化指南</a></li>
</ul>
]]></content>
      <categories>
        <category>源码阅读笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/2022/11/08/Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="cpp-基础-杂记"><a href="#cpp-基础-杂记" class="headerlink" title="cpp 基础 杂记"></a>cpp 基础 杂记</h3><ul>
<li>数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sizeof(arr) 获取整个数组所占空间</p>
</li>
<li><p>sizeof(arr[0]) 获取单个元素所占空间</p>
</li>
<li><p>指针</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  var = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>*ip;<span class="comment">// pointe 定义指针 内容为对应的地址 </span></span><br><span class="line">ip = &amp;var; <span class="comment">// 设置ip为 var变量的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *ip &lt;&lt; endl; <span class="comment">// 取值操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中数组比较特别，变量等同于数组的首项的地址</p>
<ul>
<li><p>指针与函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">// &amp; 取地址</span></span><br><span class="line"><span class="comment">// 地址传递可以做到修改传入的参数的值，默认情况下为值传递，不能做到对实参修改，但是地址传递可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[] 数组的地址也是名字</span></span></span><br><span class="line"><span class="function"></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">17</span>;   </span><br><span class="line"><span class="type">int</span>&amp; r = i;</span><br></pre></td></tr></table></figure>
<p>引用必须初始化，并且初始化后，不可以改变<br>此时 r变量和i变量相当是一样的，i的内容改变，r的内容也会改变，可以理解为变量的地址是一样的，赋值时相当于向同样的地址中存值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line"><span class="comment">// 引用对于函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mySwap03</span>(a, b); </span><br><span class="line"><span class="comment">// 同样可以做到和指针一样的效果，对实参进行修改</span></span><br></pre></td></tr></table></figure>
<p>引用的本质为指针常量，特殊用法，可以放到等号的左侧接受别的值，作为函数返回时，不能返回局部变量，但是可以返回静态变量引用，需要<code>static</code>修饰符</p>
<ul>
<li><p>内存</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量 和 字符串常量</li>
</ul>
</li>
<li><p>new 操作符可以手动开辟自己的数据空间(堆区)，通过delete释放</p>
</li>
<li><p>类<br>可以通过<code>class</code>和<code>struct</code>定义类，默认权限<code>class</code>为私有，<code>struct</code>(结构体)为公共</p>
</li>
</ul>
<p>class三种权限</p>
<ul>
<li>公共权限  public     类内可以访问  类外可以访问</li>
<li>保护权限  protected  类内可以访问  类外不可以访问</li>
<li>私有权限  private    类内可以访问  类外不可以访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age; <span class="comment">// this 为最后生成的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a-&gt;b  a 为指针</span></span><br><span class="line"><span class="comment">// a.b   a 为实体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>友元<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以访问到权限更大的属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>模块</title>
    <url>/2023/02/20/%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>需要满足的特性：独立性、完整性、可依赖、被依赖</li>
</ul>
<h4 id="原始模块"><a href="#原始模块" class="headerlink" title="原始模块"></a>原始模块</h4><p>使用函数作为独立模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">mod, $</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">clone</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clone&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mod.<span class="property">clone</span> = clone</span><br><span class="line">&#125;)(<span class="variable language_">window</span>.<span class="property">clone</span> = <span class="variable language_">window</span>.<span class="property">clone</span> || &#123;&#125;, jQuery)</span><br></pre></td></tr></table></figure>

<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul>
<li>异步模块加载规范，为浏览器设计<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure>
需要使用<code>RequireJs</code>（AMD模块加载器）加载模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;clone&#x27;</span>], <span class="keyword">function</span> (<span class="params">clone</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = &#123; <span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="title function_">clone</span>(a) <span class="comment">// 使用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul>
<li>同步模块加载规范，主要用于node环境<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>)&#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
在node环境中define自动生成，不需要开发者手写<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = clone; <span class="comment">// 模块导出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">require</span>(<span class="string">&#x27;./clone.js&#x27;</span>) <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a =  &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">clone</span>(a) <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><ul>
<li>通用模块加载规范，不是一个新的规范，而是对前面多种规范的整合<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root,factory</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title function_">factory</span>(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="comment">// AMD 情况</span></span><br><span class="line">        <span class="title function_">define</span>(<span class="string">&#x27;clone&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// CommonJs 情况</span></span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = clone;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原始模块 情况</span></span><br><span class="line">        <span class="keyword">var</span> _clone = root.<span class="property">clone</span>;</span><br><span class="line"></span><br><span class="line">        clone.<span class="property">noConflict</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//解决全局命名冲突问题</span></span><br><span class="line">            <span class="keyword">if</span>(root.<span class="property">clone</span> === clone) &#123;</span><br><span class="line">                root.<span class="property">clone</span> = _clone</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">        &#125;</span><br><span class="line">        root.<span class="property">clone</span> = clone</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params">root</span>) &#123; </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">        <span class="comment">// xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义并导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;clone&#125; <span class="keyword">from</span> <span class="string">&#x27;./clone.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> a =  &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">clone</span>(a) <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2023/03/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>在工厂内根据不同类型，直接返回对应类的实例</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类，无法被实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="title function_">cosntructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create user&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create customer&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create admin&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">$type</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;user&#x27;</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;customer&#x27;</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;admin&#x27;</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&#x27;传递的用户类型错误。&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="title class_">PersonFactory</span>.<span class="title function_">create</span>(<span class="string">&#x27;user&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点：拓展性差，每次增加都需要在工厂函数中修改代码</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>解决<code>简单工厂模式</code>中存在的判断情况，为每一个类创建自己的工厂<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Button</span> &#123; </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getInstance</span>() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create window button&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create mac Button&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowButtonFactory</span> <span class="keyword">implements</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowButton</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButtonFactory</span> <span class="keyword">implements</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">WindowButtoFactory</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = f.<span class="title function_">getInstanc</span>()</span><br></pre></td></tr></table></figure></li>
<li>缺点：每次增加类，都需要创建不同的工厂类，增加了代码的复杂度</li>
</ul>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><ul>
<li>为了解决<code>工厂方法模式</code>实现子类过多的情况，可以把产品进行分类，生成多个工厂组合成产品的模式<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Keyboard</span> &#123;</span><br><span class="line">    <span class="title function_">print</span>() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacKeyboard</span> <span class="keyword">implements</span> <span class="title class_">Keyboard</span> &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create mac keyboard&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowKeyboard</span> <span class="keyword">implements</span> <span class="title class_">Keyboard</span> &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create window keyboard&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line">    <span class="title function_">play</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacMonitor</span> <span class="keyword">implements</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line">    <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is Mac monitor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowMonitor</span> <span class="keyword">implements</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line">    <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is window monitor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createKeyboard</span>()</span><br><span class="line">    <span class="title function_">createMonitor</span>() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createKeyboard</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacKeyboard</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacMonitor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createKeyboard</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowKeyboard</span>() </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowMonitor</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">f.<span class="title function_">createKeyboard</span>()</span><br><span class="line">f.<span class="title function_">createMonitor</span>()</span><br></pre></td></tr></table></figure></li>
<li>优缺点：增加工厂比较简单，但是增加产品类型需要添加较多代码，需要定义和实现，并需要在工厂函数中添加</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>简单工厂：唯一工厂类，一个产品抽象类</li>
<li>工厂方法：多个工厂类，一个产品抽象类</li>
<li>抽象工厂：多个工厂类，多个产品抽象类</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器模式</title>
    <url>/2023/03/10/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><ul>
<li>该模式中有四种角色：<ul>
<li>生成器（Builder）</li>
<li>具体生成器（Concreate Builders）</li>
<li>产品（product）</li>
<li>主管（Director）<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create car&#x27;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManual</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create carManual&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="title function_">reset</span>()</span><br><span class="line">    <span class="title function_">setSeats</span>() </span><br><span class="line">    <span class="title function_">setGPS</span>()</span><br><span class="line">    <span class="title function_">getProduct</span>() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setSeats</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setGPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> car = <span class="variable language_">this</span>.<span class="property">car</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">        <span class="keyword">return</span> car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">manual</span> = <span class="keyword">new</span> <span class="title class_">CarManual</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setSeats</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setGPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> manual = <span class="variable language_">this</span>.<span class="property">manual</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">        <span class="keyword">return</span> manual</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主管</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="title function_">constructorSportsCar</span>(<span class="params">builder:Builder</span>) &#123;</span><br><span class="line">        builder.<span class="title function_">reset</span>()</span><br><span class="line">        builder.<span class="title function_">setSets</span>()</span><br><span class="line">        builder.<span class="title function_">setGPS</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructorSUVCar</span>(<span class="params">builder:Builder</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> director = <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carBuilder = <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">director.<span class="title function_">constructSportsCar</span>(carBuilder)</span><br><span class="line"><span class="keyword">let</span> car = carBuilder.<span class="title function_">getProduct</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carManualBuilder = <span class="keyword">new</span> <span class="title class_">CarManulBuilder</span>() </span><br><span class="line">director.<span class="title function_">constructorSportsCar</span>(carManualBuilder)</span><br><span class="line"><span class="keyword">let</span> manual = carManualBuilder.<span class="title function_">getProduct</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点： <ul>
<li>可以分步创建产品</li>
<li>生成不同产品可以使用类似的代码</li>
<li>可以将复杂的构造代码与产品逻辑分离出来</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要新增多个类，复杂度会有所提高</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
