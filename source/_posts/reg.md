---
title: 正则表达式
date: 2018-06-03 16:09:16
tags: [web,js,reg]
categories: 学习笔记
---
正则表达式基础学习
<!-- more -->

##### 正则表达式的创建
    1. var reg = /pattern/;
    2. var reg = new RegExp('pattern');
    
###### 字符类
    
|字符|匹配|
|-|-|
|[...]|方括号内的任意字符|
|[^...]|不在方括号内的任意字符|
|.|除换行符和其他Unicode行终止符之外的任意字符|
|\w|任何ASCII字符组成的单词，等价于[a-zA-Z0-9]|
|\W|任何非ASCII字符组成的单词，等价于[^a-zA-Z0-9]|
|\s|任何Unicode空白符|
|\S|任何非Unicode空白符的字符|
|\d|任何ASCII数字，等价于[0-9]|
|\D|除了ASCII数字之外的任何字符，等价于[^0-9]|
|[\b]|退格直接量（特例）|

###### 重复

|字符|含义|
|-|-|
|{n,m}|匹配前一项至少n次，但不超过m次|
|{n,}|匹配前一项n次或者更多次|
|{n}|匹配前一项n次|
|?|匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}|
|+|匹配前一项1次或多次，等价于{1,}|
|*|匹配前一项0次或多次，等价于{0,}|
    

非贪婪的重复：上面的重复匹配字符是尽可能多的匹配字符，这种成为贪婪的重复，如果需要尽可能少的匹配，这种称为非贪婪的重复，只需要在待匹配的字符后面加一个?即可，有的时候会有一些与期望不同的情况，所以在实际使用的时候注意正则匹配的原理，它是从开头进行匹配的，不会进行跳跃

###### 选择、分组和引用

|字符|含义|
|-|-|
| &#124;|选择，匹配的是该符号左边的子表达式或右边的子表达式|
|(...)|组合，将集合项合并成一个单元，可用过'*'、'+'、'?'和'&#124;'等符号加以修饰，而且可以记住这个匹配的字符，供后面的引用使用|
|(?:...)|只组合，与上面的基本相同，唯一的区别是不会记忆匹配的字符，后面无法引用|
|\n|引用，和前面的(...)一起使用，找和第n和括号匹配的记忆字符，注意查第几个的时候以左括号为基准|

###### 指定匹配位置

|字符|含义|
|-|-|
|^|匹配字符串开头|
|$|匹配字符串结尾|
|\b|匹配一个单词的边界|
|\B|匹配非单词边界的位置|
|(?=p)|零宽正向先行判断，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符（匹配结果不包括p）|
|(?!p)|零宽负向先行判断，要求接下来的字符不与p匹配|

###### 修饰符

|字符|含义|
|-|-|
|i|执行不区分大小写的匹配|
|g|执行一个全局匹配|
|m|多行匹配|

##### 用于匹配的string方法
 - search()     参数为正则表达式，返回匹配成功的子串的起始位置，否则返回-1，不支持g，默认忽略
 - replace()    有两个参数，第一个为匹配的正则表达式，第二个为要替换成的字符串，可以为'$'+数字，与正则表达式中的引用相同，只不过这里用'&'而不是'\'，第二个参数也可以是一个函数，必须有一个返回值，返回值为替换的值，这个函数的参数为匹配成功的字符串
 - match()      返回值为一个数组，其中，当参数正则表达式执行的不是全局检索（g）时，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且只返回第一个匹配成功的；否则，会返回所有满足正则表达式的元素构成的数组，不返回括号中的子表达式    
 - split()      该方法把字符串按照参数拆分成数组，参数可以为正则表达式

##### RegExp对象
 - 属性
    global：是否有g属性    ignoreCase：是否有i属性      multiline：是否有m属性     lastIndex：最后匹配的字符位置（注意，在一些匹配的时候需要重置）      source：对应正则表达式的源文本
 - 方法
  - exec()   返回值为一个数组，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且只返回第一个匹配成功的，返回值有index（发生匹配的位置）和input（正在检索的字符串）属性，当同一个正则表达式再次调用的时候，会从lastIndex继续检索，返回值相同，当没有匹配结果的时候，lastIndex重置为0
  - test()  判断时候匹配，成功返回true，否则返回false