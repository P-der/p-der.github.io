---
title: 工厂模式
date: 2023-03-10 19:26:09
tags: [设计模式]
---


### 简单工厂模式
- 在工厂内根据不同类型，直接返回对应类的实例
 
``` typescript
// 抽象类，无法被实例化
abstract class Person { 
    cosntructor() {
        console.log('error')
    }
}
class User extends Person {
    constructor() {
        console.log('create user')
    }
}
class Customer extends Person {
    constructor() {
        console.log('create customer')
    }
}
class Admin extends Person {
    constructor() {
        console.log('create admin')
    }
}
class PersonFactory {
    static create($type) {
        switch ($type) {
            case 'user': return new User();
            case 'customer': return new Customer();
            case 'admin': return new Admin();
            default:
                throw new Exception('传递的用户类型错误。');
        }
    }
}
// 使用
let user = PersonFactory.create('user')
```
- 缺点：拓展性差，每次增加都需要在工厂函数中修改代码
  
### 工厂方法模式
- 解决`简单工厂模式`中存在的判断情况，为每一个类创建自己的工厂
``` typescript 
abstract class Button { 
    constructor() {
        console.log('error')
    }
}
abstract class ButtonFactory {
    constructor() {
        console.log('error')
    }
    getInstance() 
}

class WindowButton implements Button {
    constructor() {
        console.log('create window button')
    }
}

class MacButton implements Button {
    constructor() {
        console.log('create mac Button')
    }
}

class WindowButtonFactory implements ButtonFactory {
    getInstance() {
        return new WindowButton()
    }
}

class MacButtonFactory implements ButtonFactory {
    getInstance() {
        return new MacButton()
    }
}
// 使用
let f = new WindowButtoFactory()

let b = f.getInstanc()
```
- 缺点：每次增加类，都需要创建不同的工厂类，增加了代码的复杂度

### 抽象工厂
- 为了解决`工厂方法模式`实现子类过多的情况，可以把产品进行分类，生成多个工厂组合成产品的模式
``` typescript
abstract class Keyboard {
    print() 
}

class MacKeyboard implements Keyboard {
    print() {
        console.log('create mac keyboard')
    }
}

class WindowKeyboard implements Keyboard {
    print() {
        console.log('create window keyboard')
    }
}

abstract class Monitor {
    play()
}

class MacMonitor implements Monitor {
    play() {
        console.log('this is Mac monitor')
    }
}

class WindowMonitor implements Monitor {
    play() {
        console.log('this is window monitor')
    }
}

abstract class Factory {
    createKeyboard()
    createMonitor() 
}

class MacFactory implements Factory {
    createKeyboard() {
        return new MacKeyboard()
    }
    createMonitor() {
        return new MacMonitor()
    }
}

class WindowFactory implements Factory {
    createKeyboard() {
        return new WindowKeyboard() 
    }
    createMonitor() {
        return new WindowMonitor()
    }
}

// 使用
let f = new MacFactory()
f.createKeyboard()
f.createMonitor()
```
- 优缺点：增加工厂比较简单，但是增加产品类型需要添加较多代码，需要定义和实现，并需要在工厂函数中添加

### 总结

- 简单工厂：唯一工厂类，一个产品抽象类
- 工厂方法：多个工厂类，一个产品抽象类
- 抽象工厂：多个工厂类，多个产品抽象类